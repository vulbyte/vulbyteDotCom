<!-- 0000-tib.html -->
<!DOCTYPE html>
<html lang="en" style="margin-bottom:0;">

<head>
	<meta charset="UTF-8">
	<!-- https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP -->
	<!--<meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self';">-->
	<title>cockatiel | by @vulbyte</title>
	<script type="module" src="/client_management.js"></script>
	<script type="module">
		import PopUp from './tib_stuff/popup.js';
		window.PopUp = new PopUp();
		import MonitorMessages from './tib_stuff/monitorMessages.js';
		window.monitorMessages = new MonitorMessages();
		import YoutubeStuff from './tib_stuff/youtubeStuff.js';
		window.YoutubeStuff = new YoutubeStuff();
		import {assert} from './tib_stuff/assert.js';
		window.assert = assert;
		import {IntTimer} from './tib_stuff/intTimer.js';
		window.IntTimer = new IntTimer();
	</script>
	<div style="
			background-color: #000; /* Example background color */
			border-top: solid white 0.1em;
			bottom: 0;
			color: var(--color_primary); /* Example text color */
			display:flex;
			justify-content: space-between;
			left: 0;
			padding-top: 0.5em;
			position: fixed;
			text-align: center;
			height:min-content;
			width: 100%;
		"> <!-- this group is for the controls stuck to the bottom of the screen -->
		<!-- {{{7 controls-->
		<div style="display:flex; flex-direction:column; z-index:1000;">
			<button type="button" id="sai" style="background-color:lightgreen;">save all inputs</button>
			<button type="button" id="lai" style="background-color:powderblue;">load all inputs</button>
			<script type="module">
				window.addEventListener('DOMContentLoaded', (e) => {
					let sai = document.getElementById("sai");
					let lai = document.getElementById("lai");

					let inputs = document.getElementsByTagName("input");
					let input;
					sai.addEventListener("click", (e) => {
						console.log("saving inputs");
						for (let i = 0; i < inputs.length; ++i) {
							input = inputs[i];
							localStorage.setItem(String(input.id), input.value);
						}
					});

					lai.addEventListener("click", (e) => {
						console.log("loading inputs");
						for (let i = 0; i < inputs.length; ++i) {
							try {
								if(inputs[i] == undefined){
									console.warn(`input at the index ${i} is undefined, skipping`);
									continue;
								}
								input = inputs[i];
								input.value = localStorage.getItem(String(input.id));
							}
							catch (err) {
								console.error("unable to assign value:\n" + input[i] + "\n" + err);
							}
						}
					});
				});
			</script>
		</div>
		<!-- }}}7 -->

		<!-- {{{7 start/stop functions -->
		<style>
			#function_buttons {
				width: 16em;
				display: flex;
				flex-direction: column;
				padding-top: 0.7em;
			}

			#function_buttons>div {
				margin: 0px;
				padding: 0px;
			}

			#function_buttons>*>button {
				margin: auto;
				width: 12em;
			}
		</style>
		<div id='function_buttons'>
			<button type="button" id='start_monitoring_button' style='background-color: darkgreen;'>start monitoring </button> 
			<script type="module">
					window.addEventListener('DOMContentLoaded', () => {
						document.getElementById('start_monitoring_button').addEventListener('click', () => {
							console.log('start_monitoring_button clicked');
							window.monitorMessages.MonitoringStart();
						})
					});
			</script>
			<button type="button" id='stop_monitoring_button' style='background-color: darkred;'
				onclick="window.monitorMessages.MonitoringStop()">stop monitoring</button>
		</div>
		<!-- {{{7 start/stop + auto tts functions -->
		<style>
			#function_buttons {
				width: 16em;
				display: flex;
				flex-direction: column;
				padding-top: 0.7em;
			}

			#function_buttons>div {
				margin: 0px;
				padding: 0px;
			}

			#function_buttons>*>button {
				margin: auto;
				width: 12em;
			}
		</style>
		<div id='function_buttons'>
			<button type="button" id='start_tts_button' style='background-color: darkblue; color: white;'>start auto tts</button>
			<button type="button" id='pause_tts_button' style='background-color: goldenrod;'>pause auto tts</button>
			<br>
			<label for="timeout_duration">timeout duration (seconds)</label>
			<input id="timeout_duration" type="number" value="300" min="10" step="10" />
		</div>
		<script type='module'>
			window.addEventListener('DOMContentLoaded', () => {
				// ############################################################
				// helper to update button states
				// ############################################################
					const startBtn = document.getElementById('start_tts_button');
					const stopBtn = document.getElementById('pause_tts_button');

					startBtn.addEventListener('click', () => {
						window.monitorMessages.AutoTtsStart();
					});

					stopBtn.addEventListener('click', () => {
						window.monitorMessages.AutoTtsStop();
					});
			});
		</script>
		<!-- }}}7 -->

		<!-- {{{7 updates -->
		<style>
			:root {
				--guage_size: 2em;
			}

			.guage {
				/* This is the outer circle, acting as the background track */
				height: calc(var(--guage_size) * 1);
				width: calc(var(--guage_size) * 1);
				border-radius: 50%;
				background: conic-gradient(#ff0 0%,
						#f0f 33%,
						#0ff 66%,
						#ff0 100%);
				position: relative;
				/* Needed for positioning the inner circle */
				display: grid;
				place-items: center;
				cursor: default;
			}

			.guage_mask {
				background: conic-gradient(transparent 0%,
						transparent 80%,
						#000 80%,
						#000 100%);
				position: absolute;
				border-radius: 50%;
				top: 50%;
				left: 50%;
				transform: translate(-50%, -50%) rotate(-145deg);
				height: calc(var(--guage_size) * 1.1);
				width: calc(var(--guage_size) * 1.1);
				z-index: 99;
			}

			.guage::after {
				content: "";
				display: block;
				position: absolute;
				height: calc(var(--guage_size) * 0.7);
				width: calc(var(--guage_size) * 0.7);
				border-radius: 50%;
				background-color: black;
				top: 50%;
				left: 50%;
				transform: translate(-50%, -50%);
			}

			.guage-inner {
				position: absolute;
				top: 50%;
				left: 50%;
				transform: translate(-50%, -50%);
				font-size: calc(var(--guage_size)*0.3);
				z-index: 100;
			}

			#update_info>div {
				display: flex;
				justify-content: space-between;
				padding-left: 1em;
				padding-right: 1em;
			}

			#update_info :nth-child(1) {}

			#update_info>div:nth-child(2)>label,
			#update_info>div:nth-child(2)>span {
				color: color-mix(in oklab, #f0f, white);
			}

			#update_info>div:nth-child(3)>label,
			#update_info>div:nth-child(3)>span {
				color: color-mix(in oklab, #ff0, white);
			}

			#update_info>div:nth-child(4)>label,
			#update_info>div:nth-child(4)>span {
				color: color-mix(in oklab, #0ff, white);
			}
		</style>
		<!--
		<div id="update_info" style="
				border:solid white 0.1em;
				display:flex;  
				flex-direction:column;
				margin:0.2em;
				padding:0.2em;
				text-align:left; 
				width:16em; 
		">
			<div>
				<label>next update:</label>
				<div class="guage">
					<div class="guage_mask"></div>
					<div class="guage-inner">
						<span>164</span>
					</div>
				</div>
			</div>
			<div><label>tts queue:</label><span>999</span>
			</div>
			<div><label>tts messages read:</label><span>1000</span>
			</div>
			<div><label>total messages:</label><span>9999</span>
			</div>
		</div>
-->
		<!-- }}}7 -->
	</div>
</head>

<h1>NOTHING HERE IS FINISHED, IF YOU FOUND YOUR WAY HERE NOTHING ON THIS PAGE IS COMMITTAL AND MANY FEATURES ARE BROKEN/BEING WORKED ON LIVE.</h1>


<br>

<body style="">
	<script type="module">
		window.addEventListener('beforeunload', function (event) {
			// Check if there is unsaved data before showing the alert
			const hasUnsavedChanges = true; // Replace with your actual check (e.g., a boolean flag)

			if (hasUnsavedChanges) {
				// Cancel the event.
				event.preventDefault("the data has not been saved yet, please give me a sec to save the data!");

				// Chrome requires returnValue to be set.
				event.returnValue = 'the data base has not been backed up yet and will new values will not be saved!';

				// The actual text displayed to the user is determined by the browser
				// and is usually a standard message like "Are you sure you want to leave?"
				// You cannot customize the actual message shown in modern browsers.
			}
		});
	</script>
	<details>
		<summary>TiB config: click here to edit the cost of actions and defaults</summary>
		<div><label>voice:</label><input type="number" default="51"></div>
		<div><label>pitch:</label><input type="number" default="1.1"></div>
		<div><label>rate:</label><input type="number" default="0.9"></div>
		<div><label>soundboard cost:</label><input type="number" value="1000"></div>
		<div><label>tts cost:</label><input type="number" value="3000"></div>
	</details>

	<details>
		<summary>messageScoreChecker</summary>
		<div>
			<lavel>score:</lavel>
			<output id="messageScoreTest">0</output>
		</div>
		<textarea id="messageScoreCheck"></textarea>
		<script type="module">
			window.addEventListener('load', () => {

				let testArea = document.getElementById("messageScoreCheck");
				let messageScore = document.getElementById("messageScoreTest");

				let data;
				console.log("adding score checker listener");
				testArea.addEventListener("change", (e) => {
					window.monitorMessages.ScoreMessage(testArea.value)
						.then((res) => {
							console.log("calcing score")
							data = res;
							console.log(data);
							messageScore.innerText = data;
						});
				});
			});
		</script>
	</details>

	<hgroup style="display:flex; justify-content:space-around;">
		<!--<img style="max-height:100%; width:3em;" src="./non-code_assets/cockatiel_logo.png">-->
		<h1>cockatiel</h1>
		<h6>by vulbyte</h6>
		<img style="max-height:100%; width:3em;"
			src='https://raw.githubusercontent.com/vulbyte/vulbyteDotCom/0b0fcb64b46a2665d622ce094517332ab6b6cb7f/assets/dev_icon.svg'>
	</hgroup>

	<div>
		<form id="upload_form">
			<div>
				<label>load unprocessed message</label>
				<input type="file">
			</div>
			<div>
				<label>load processed message</label>
				<input type="file">
			</div>
			<div>
				<label>load users data</label>
				<input type="file">
				</div>
					<div>
						<input type="button" style="background-color:var(--color_confirm); color: black;"
							 onclick='(()=>(
				let uf = document.getElementById("upload_form");
				let data = new FormData(uf);
				data = Object.fromEnteries(data);

				window.monitorMessages.AddMessa
			))()' value="load data into system"></label>
					</div>
		</form>
	</div>
	
	<div>
		<details style=""><summary>üß™ the process + testing üß™</summary>
			<details><summary>process</summary>
			<div>
			<aside>the ‚ú® redenotes a flow that requires you to have a subscription atleast at a "mega-teir" to use.</aside>
			<div style="color:#ccc;">get channel data from platform</div>
			<div style="display:flex;"><div>‚Üì</div></div>
			<div style="color:#ccc;">receive messages from platform in native format</div>
			<div style="display:flex;"><div>‚Üì</div></div>
			<div style="color:#ccc;">add messages to unprocessed que for later processing</div>
			<div style="display:flex;"><div>‚Üì</div><div>‚ú®‚Üíadd messages to unproccessed db for quickstart and archival-ness.</div></div>
			<div style="color:#ccc;">parse unprocessed and format them into the cockiteal format</div>
			<div style="display:flex;"><div>‚Üì</div><div>‚ú®‚Üíadd messages to message db queue, can add mods to view and monitor these messages</div></div>
			<div style="color:#ccc;">do whatever the message entales</div>
			</div>
			</details>
			<div>
					<form>
				<h3>testing</h3>
				<aside>note: anything done here will not be added to the actual process, and is simply to test functionality. <br><u><em style="color:#ffb;">DO NOT USE THIS TO ADD DATA TO THE PROCESS, IT WILL NOT WORK</em></u></aside>
				<div 
					id="test-add_to_unprocessed_queue" 
					style=""
				>
						<fieldset>
							<legend>add messages to unprocessed queue:</legend>
							<div style="display:flex;">
								<div style="max-height:10em; overflow:scroll;">
									<output id="unprocessed_youtube_message_raw_response" style="max-height:10rem; overflow-y:scroll; font-family:monospace; color:var(--color_warning);">
										{
										"kind": "youtube#liveChatMessageListResponse",
										"etag": "MG3TMQnVmeK-Gj4aszUbx7HCVSM",
										"pollingIntervalMillis": 1995,
										"pageInfo": {
										"totalResults": 10,
										"resultsPerPage": 10
										},
										"nextPageToken": "GKTSjaXE35ADIOaC0L3H35AD",
										"items": [
										{
										"kind": "youtube#liveChatMessage",
										"etag": "7UKcHN1EfCGU4sMbPulLDDsM0ww",
										"id": "LCC.EhwKGkNQNno1TXZDMzVBREZVMFVyUVlkbEVJQ3p3",
										"snippet": {
										"type": "textMessageEvent",
										"liveChatId": "Cg0KC3VCVS1Pa0t5N0VVKicKGFVDS1ppZ0hiZ3BKRzlsZHhYTXFtaVpVZxILdUJVLU9rS3k3RVU",
										"authorChannelId": "UCKZigHbgpJG9ldxXMqmiZUg",
										"publishedAt": "2025-11-07T07:30:55.259559+00:00",
										"hasDisplayContent": true,
										"displayMessage": "THIS IS A REGULAR MESSAGE",
										"textMessageDetails": {
										"messageText": "THIS IS A REGULAR MESSAGE"
										}
										},
										"authorDetails": {
										"channelId": "UCKZigHbgpJG9ldxXMqmiZUg",
										"channelUrl": "http://www.youtube.com/channel/UCKZigHbgpJG9ldxXMqmiZUg",
										"displayName": "@vulbyte",
										"profileImageUrl": "https://yt3.ggpht.com/jrcU7ZjcLMBzCQbU6QMucPmC-cBiHOFrmTpDS9gDzUdH9FUTyzqgrkX9-rXzRh6Fac_HWWgNoEA=s88-c-k-c0x00ffffff-no-rj",
										"isVerified": false,
										"isChatOwner": true,
										"isChatSponsor": false,
										"isChatModerator": false
										}
										},
										{
										"kind": "youtube#liveChatMessage",
										"etag": "uW0sHBnZmDyMsu_6sly0enesYF0",
										"id": "LCC.EhwKGkNMMnh2OF9DMzVBREZXekR3Z1FkSVZ3a0RR",
										"snippet": {
										"type": "textMessageEvent",
										"liveChatId": "Cg0KC3VCVS1Pa0t5N0VVKicKGFVDS1ppZ0hiZ3BKRzlsZHhYTXFtaVpVZxILdUJVLU9rS3k3RVU",
										"authorChannelId": "UCKZigHbgpJG9ldxXMqmiZUg",
										"publishedAt": "2025-11-07T07:31:03.04114+00:00",
										"hasDisplayContent": true,
										"displayMessage": "!TTS THIS IS A TTS MESSAGE",
										"textMessageDetails": {
										"messageText": "!TTS THIS IS A TTS MESSAGE"
										}
										},
										"authorDetails": {
										"channelId": "UCKZigHbgpJG9ldxXMqmiZUg",
										"channelUrl": "http://www.youtube.com/channel/UCKZigHbgpJG9ldxXMqmiZUg",
										"displayName": "@vulbyte",
										"profileImageUrl": "https://yt3.ggpht.com/jrcU7ZjcLMBzCQbU6QMucPmC-cBiHOFrmTpDS9gDzUdH9FUTyzqgrkX9-rXzRh6Fac_HWWgNoEA=s88-c-k-c0x00ffffff-no-rj",
										"isVerified": false,
										"isChatOwner": true,
										"isChatSponsor": false,
										"isChatModerator": false
										}
										},
										{
										"kind": "youtube#liveChatMessage",
										"etag": "wtCJdyD06ttdzLCNIO1tLyhkmZs",
										"id": "LCC.EhwKGkNJeVRvOVBDMzVBREZRcm1sQWtkOGNBMkVR",
										"snippet": {
										"type": "textMessageEvent",
										"liveChatId": "Cg0KC3VCVS1Pa0t5N0VVKicKGFVDS1ppZ0hiZ3BKRzlsZHhYTXFtaVpVZxILdUJVLU9rS3k3RVU",
										"authorChannelId": "UCKZigHbgpJG9ldxXMqmiZUg",
										"publishedAt": "2025-11-07T07:31:10.966769+00:00",
										"hasDisplayContent": true,
										"displayMessage": "!CLIP THIS IS A CLIP MESSAGE",
										"textMessageDetails": {
										"messageText": "!CLIP THIS IS A CLIP MESSAGE"
										}
										},
										"authorDetails": {
										"channelId": "UCKZigHbgpJG9ldxXMqmiZUg",
										"channelUrl": "http://www.youtube.com/channel/UCKZigHbgpJG9ldxXMqmiZUg",
										"displayName": "@vulbyte",
										"profileImageUrl": "https://yt3.ggpht.com/jrcU7ZjcLMBzCQbU6QMucPmC-cBiHOFrmTpDS9gDzUdH9FUTyzqgrkX9-rXzRh6Fac_HWWgNoEA=s88-c-k-c0x00ffffff-no-rj",
										"isVerified": false,
										"isChatOwner": true,
										"isChatSponsor": false,
										"isChatModerator": false
										}
										},
										{
										"kind": "youtube#liveChatMessage",
										"etag": "IV_tEkBxHmFZ-8UWQrmPgRkWRfo",
										"id": "LCC.EhwKGkNMRGl1TWJEMzVBREZUTEtGZ2tkaEg0OHVn",
										"snippet": {
										"type": "textMessageEvent",
										"liveChatId": "Cg0KC3VCVS1Pa0t5N0VVKicKGFVDS1ppZ0hiZ3BKRzlsZHhYTXFtaVpVZxILdUJVLU9rS3k3RVU",
										"authorChannelId": "UCTn0r_p1PGYpKrLtY5wylAA",
										"publishedAt": "2025-11-07T07:35:12.494044+00:00",
										"hasDisplayContent": true,
										"displayMessage": "dsgdsgfdsfdsgdsgdsgds heloooo?",
										"textMessageDetails": {
										"messageText": "dsgdsgfdsfdsgdsgdsgds heloooo?"
										}
										},
										"authorDetails": {
										"channelId": "UCTn0r_p1PGYpKrLtY5wylAA",
										"channelUrl": "http://www.youtube.com/channel/UCTn0r_p1PGYpKrLtY5wylAA",
										"displayName": "@chilidog2469",
										"profileImageUrl": "https://yt3.ggpht.com/ytc/AIdro_ksuZOTp92qOmvcZ6HPmyqGfl9lS6iG11y617p88a_IJw=s88-c-k-c0x00ffffff-no-rj",
										"isVerified": false,
										"isChatOwner": false,
										"isChatSponsor": true,
										"isChatModerator": true
										}
										},
										{
										"kind": "youtube#liveChatMessage",
										"etag": "GqW5X8akBA1ar4yyHmUud9PALDA",
										"id": "LCC.EhwKGkNNM1g2OHpEMzVBREZVdlRsQWtkWS1rV3dn",
										"snippet": {
										"type": "textMessageEvent",
										"liveChatId": "Cg0KC3VCVS1Pa0t5N0VVKicKGFVDS1ppZ0hiZ3BKRzlsZHhYTXFtaVpVZxILdUJVLU9rS3k3RVU",
										"authorChannelId": "UCTn0r_p1PGYpKrLtY5wylAA",
										"publishedAt": "2025-11-07T07:35:25.910608+00:00",
										"hasDisplayContent": true,
										"displayMessage": "!tts -r 0.8 Tony am is summon?",
										"textMessageDetails": {
										"messageText": "!tts -r 0.8 Tony am is summon?"
										}
										},
										"authorDetails": {
										"channelId": "UCTn0r_p1PGYpKrLtY5wylAA",
										"channelUrl": "http://www.youtube.com/channel/UCTn0r_p1PGYpKrLtY5wylAA",
										"displayName": "@chilidog2469",
										"profileImageUrl": "https://yt3.ggpht.com/ytc/AIdro_ksuZOTp92qOmvcZ6HPmyqGfl9lS6iG11y617p88a_IJw=s88-c-k-c0x00ffffff-no-rj",
										"isVerified": false,
										"isChatOwner": false,
										"isChatSponsor": true,
										"isChatModerator": true
										}
										},
										{
										"kind": "youtube#liveChatMessage",
										"etag": "NRL4maYzTO3PAC_x65jzd7Ljsl0",
										"id": "LCC.EhwKGkNPMnc3TmJEMzVBREZSX0hGZ2tkUTdFdzVn",
										"snippet": {
										"type": "textMessageEvent",
										"liveChatId": "Cg0KC3VCVS1Pa0t5N0VVKicKGFVDS1ppZ0hiZ3BKRzlsZHhYTXFtaVpVZxILdUJVLU9rS3k3RVU",
										"authorChannelId": "UCTn0r_p1PGYpKrLtY5wylAA",
										"publishedAt": "2025-11-07T07:35:46.896389+00:00",
										"hasDisplayContent": true,
										"displayMessage": "!tts -r 0.8 fuzziness ACTIVATE",
										"textMessageDetails": {
										"messageText": "!tts -r 0.8 fuzziness ACTIVATE"
										}
										},
										"authorDetails": {
										"channelId": "UCTn0r_p1PGYpKrLtY5wylAA",
										"channelUrl": "http://www.youtube.com/channel/UCTn0r_p1PGYpKrLtY5wylAA",
										"displayName": "@chilidog2469",
										"profileImageUrl": "https://yt3.ggpht.com/ytc/AIdro_ksuZOTp92qOmvcZ6HPmyqGfl9lS6iG11y617p88a_IJw=s88-c-k-c0x00ffffff-no-rj",
										"isVerified": false,
										"isChatOwner": false,
										"isChatSponsor": true,
										"isChatModerator": true
										}
										},
										{
										"kind": "youtube#liveChatMessage",
										"etag": "xRdSYZdfQg3FeucV41NilTFcEGo",
										"id": "LCC.EhwKGkNJdnZfdkxEMzVBREZUYU41UWNkNkl3YUR3",
										"snippet": {
										"type": "textMessageEvent",
										"liveChatId": "Cg0KC3VCVS1Pa0t5N0VVKicKGFVDS1ppZ0hiZ3BKRzlsZHhYTXFtaVpVZxILdUJVLU9rS3k3RVU",
										"authorChannelId": "UCTn0r_p1PGYpKrLtY5wylAA",
										"publishedAt": "2025-11-07T07:36:45.918102+00:00",
										"hasDisplayContent": true,
										"displayMessage": "!tts -r 0.8do vulbibble need more?",
										"textMessageDetails": {
										"messageText": "!tts -r 0.8do vulbibble need more?"
										}
										},
										"authorDetails": {
										"channelId": "UCTn0r_p1PGYpKrLtY5wylAA",
										"channelUrl": "http://www.youtube.com/channel/UCTn0r_p1PGYpKrLtY5wylAA",
										"displayName": "@chilidog2469",
										"profileImageUrl": "https://yt3.ggpht.com/ytc/AIdro_ksuZOTp92qOmvcZ6HPmyqGfl9lS6iG11y617p88a_IJw=s88-c-k-c0x00ffffff-no-rj",
										"isVerified": false,
										"isChatOwner": false,
										"isChatSponsor": true,
										"isChatModerator": true
										}
										},
										{
										"kind": "youtube#liveChatMessage",
										"etag": "uMKQfRxn2Kwx57iPSnoi-Xb81Fg",
										"id": "LCC.EhwKGkNJR3Y5SlRFMzVBREZYalp3Z1FkeHY4SV9R",
										"snippet": {
										"type": "textMessageEvent",
										"liveChatId": "Cg0KC3VCVS1Pa0t5N0VVKicKGFVDS1ppZ0hiZ3BKRzlsZHhYTXFtaVpVZxILdUJVLU9rS3k3RVU",
										"authorChannelId": "UCKZigHbgpJG9ldxXMqmiZUg",
										"publishedAt": "2025-11-07T07:37:57.049178+00:00",
										"hasDisplayContent": true,
										"displayMessage": "no! thanks very much!",
										"textMessageDetails": {
										"messageText": "no! thanks very much!"
										}
										},
										"authorDetails": {
										"channelId": "UCKZigHbgpJG9ldxXMqmiZUg",
										"channelUrl": "http://www.youtube.com/channel/UCKZigHbgpJG9ldxXMqmiZUg",
										"displayName": "@vulbyte",
										"profileImageUrl": "https://yt3.ggpht.com/jrcU7ZjcLMBzCQbU6QMucPmC-cBiHOFrmTpDS9gDzUdH9FUTyzqgrkX9-rXzRh6Fac_HWWgNoEA=s88-c-k-c0x00ffffff-no-rj",
										"isVerified": false,
										"isChatOwner": true,
										"isChatSponsor": false,
										"isChatModerator": false
										}
										},
										{
										"kind": "youtube#liveChatMessage",
										"etag": "dZQlyvg47nGOfZl5e_1gT1Xwxws",
										"id": "LCC.EhwKGkNMTzVocHJFMzVBREZVWUVMd2dkS29VdDJn",
										"snippet": {
										"type": "textMessageEvent",
										"liveChatId": "Cg0KC3VCVS1Pa0t5N0VVKicKGFVDS1ppZ0hiZ3BKRzlsZHhYTXFtaVpVZxILdUJVLU9rS3k3RVU",
										"authorChannelId": "UCTn0r_p1PGYpKrLtY5wylAA",
										"publishedAt": "2025-11-07T07:38:07.831271+00:00",
										"hasDisplayContent": true,
										"displayMessage": "we done here?",
										"textMessageDetails": {
										"messageText": "we done here?"
										}
										},
										"authorDetails": {
										"channelId": "UCTn0r_p1PGYpKrLtY5wylAA",
										"channelUrl": "http://www.youtube.com/channel/UCTn0r_p1PGYpKrLtY5wylAA",
										"displayName": "@chilidog2469",
										"profileImageUrl": "https://yt3.ggpht.com/ytc/AIdro_ksuZOTp92qOmvcZ6HPmyqGfl9lS6iG11y617p88a_IJw=s88-c-k-c0x00ffffff-no-rj",
										"isVerified": false,
										"isChatOwner": false,
										"isChatSponsor": true,
										"isChatModerator": true
										}
										},
										{
										"kind": "youtube#liveChatMessage",
										"etag": "wZedzx5281klRig9yMhCWpSxXks",
										"id": "LCC.EhwKGkNQekVqYVhFMzVBREZhczlyUVlkRks0UlFR",
										"snippet": {
										"type": "textMessageEvent",
										"liveChatId": "Cg0KC3VCVS1Pa0t5N0VVKicKGFVDS1ppZ0hiZ3BKRzlsZHhYTXFtaVpVZxILdUJVLU9rS3k3RVU",
										"authorChannelId": "UCKZigHbgpJG9ldxXMqmiZUg",
										"publishedAt": "2025-11-07T07:38:31.015716+00:00",
										"hasDisplayContent": true,
										"displayMessage": "yee, dms",
										"textMessageDetails": {
										"messageText": "yee, dms"
										}
										},
										"authorDetails": {
										"channelId": "UCKZigHbgpJG9ldxXMqmiZUg",
										"channelUrl": "http://www.youtube.com/channel/UCKZigHbgpJG9ldxXMqmiZUg",
										"displayName": "@vulbyte",
										"profileImageUrl": "https://yt3.ggpht.com/jrcU7ZjcLMBzCQbU6QMucPmC-cBiHOFrmTpDS9gDzUdH9FUTyzqgrkX9-rXzRh6Fac_HWWgNoEA=s88-c-k-c0x00ffffff-no-rj",
										"isVerified": false,
										"isChatOwner": true,
										"isChatSponsor": false,
										"isChatModerator": false
										}
										}
										]
										}
									</output>
									<div>
										<label>valid_input_valid?:</label>
										<output id="valid_unprocessed_message_input_valid">ü¶ú</output>
									</div>	

									<script type="module">
										window.addEventListener("DOMContentLoaded", () => {	
											console.log("evaluating test input");
											const d = document;
											const input = d.getElementById("unprocessed_youtube_message_raw_response").innerHTML;
											const out = d.getElementById("valid_unprocessed_message_input_valid");
											try{
												JSON.parse(input);
												console.log("test input pass");
												out.innerHTML = "‚úÖ";	
											}
											catch(err){
												console.error(`INPUT JSON IS NOT VALID\n${input}\n`, err);
												out.innerHTML = "‚ùå";	
											}
										});
									</script>
								</div>
								<input 
									type="button" 
									value="test with valid input"
									style="
										background-color:var(--color_confirm); 
										color:black;
								">
								<div>
								<input type="file">
								<input 
									type="button" 
									value="test with input" 
									style="
										background-color:var(--color_warning); 
										color:black;
										height:fit-content;
								">
								</div>
							</div>
					<div class="test-status_lights" style="display:flex; justify-content:space-around;">
						<div><label>input_valid:</label><output>ü¶ú</output></div>	
						<div><label>completed_successfully:</label><output>ü¶ú</output></div>	
					</div>
						</fieldset>
			</div>
					</form>
		</details>
	</div>

	<div>
		<h2>stream info</h2>
		<div style='margin:auto; width: 80%;'>

			<style>
				#new_list {
					width: 80%;
				}

				#new_list>li {
					display: flex;
					justify-content: space-between;
					margin: auto;
					width: 89%;
				}

				#new_list>li>div {
					padding-bottom: 0px;
					margin-bottom: 0px;
				}

				#new_list>li>div>* {
					margin-right: 0.5em;
				}

				#new_list>li>label {
					padding-top: 0.7em;
				}

				#youtube_settings>li>div {
					margin-bottom: 0px;
					padding-bottom: 0px;
				}
			</style>

			<br>

		</div>

	</div>
	<div>
		<style>
			#youtube-config,
			#youtube-config>*,
			#youtube-config>*>*,
			#youtube-config>*>*>*,
			#youtube-config>*>*>*>* {
				background-color: #ff000022;
				color: #ddd !important;
				font-family: Helvetica, sans-serif, Arial !important;
				border-radius: 0.5em;
				padding-bottom: 0.3em;
			}

			.yt_form-input_container {
				display: flex;
				flex-direction: column;
			}

			.yt_form-input_container>label {
				display: inline-block;
				width: 8em;
			}

			.yt_form-input_container>input {}
		</style>
		<form id="youtube-config">
			<details>
				<summary>youtube specific config</summary>
				<fieldset>
					<legend>public info</legend>
					<div class="yt_form-input_container">
						<label>channelName</label>
						<input type="text">
					</div>
					<div class="yt_form-input_container">
						<label>apiKey</label>
						<em>DO NOT SHARE THIS OR YOU COULD GET BANNED</em>
						<input type="password">
						<aside>this value will not have a toggle visable option to prevent leaks</aside>
					</div>
					<div class="yt_form-input_container">
						<label>channelId</label>
						<button type="button" style="background-color:white; color:black !important; padding-top:0.3em;" onclick='(async () => {
								console.log("getting youtube-channelId!");
								let api = document.getElementById("youtube-apiKey"); 
								let channelName = document.getElementById("youtube-channelName"); 

								if (!api || !channelName || !channelName.value.trim()) {
									console.warn("youtube-wizard triggered in an invalid state"); 
									return;
								}; 

								let newConfigValues = {}; 
								let id = "channelId"; 

								try { 
									// 1. Await the promise returned by the getter function
									const channelIdResult = await window.monitorMessages.yt.GetChannelIdFromChannelName(channelName.value.trim());

									// 2. Assign the result to the config object
									newConfigValues[id] = channelIdResult;

									if (!newConfigValues[id]) {
										// Check if the result is valid
										throw new Error("Failed to retrieve a valid channel ID.");
									}

									// 3. Await the config update call
									await window.monitorMessages.yt.UpdateConfig(newConfigValues); 

									// 4. Update the UI
									document.getElementById("youtube-" + id).value = newConfigValues[id]; 

								} catch (err) { 
									console.error("Originalame error:", err);
									alert("Could not get or update channelId: " + (err.message || "Unknown error."));
									// We re-throw or handle the error, avoiding the direct unspecific throw
								}
							})()'>
							click to get channelId
						</button>
						<input type="text">
						<style>
							/* Styles for the main container wrapping all streams */
							#youtube-stream_selection {
								color: white;
								display: grid;
								grid-template-columns: repeat(auto-fit, minmax(10em, 1fr));
								gap: 0.8em;
								padding: 1em;
								background-color: black;
							}

							/* Styles for a single stream container (Card) */
							.stream-card {
								/*
								height: 18rem;
								width: 32em;*/
								aspect-ratio: 1.5/1;
								border-radius: 1rem;
								position: relative;
								cursor: pointer;
								background-color: #fff;
								overflow: hidden;
							}

							/* Styles for the section holding the thumbnail and button */
							.thumbnail-container {
								/*
								position: relative;
								width: 90%;
								height: 180px;
								overflow: hidden;*/
							}

							/* Styles for the thumbnail image */
							.thumbnail-img {
								position: absolute;
								width: 100%;
								height: 100%;
								object-fit: cover;
								display: block;
							}

							/* Styles for the selection button overlay */
							.selection-button {
								position: absolute;
								top: 0;
								left: 0;
								width: 100%;
								height: 100%;
								background-color: #000000AA;
								color: white;
								font-size: 1.5em;
								border: none;
								cursor: pointer;
								opacity: 1;
								transition: opacity 0.2s;
								z-index: 10;
								border-radius: 0px;
							}

							.selection-button:hover {
								background-color: #000000CC;
							}

							/* Styles for the area below the thumbnail (Icon and Text) */
							.info-container {
								background-image: linear-gradient(0deg,
										#00000099 0%,
										#00000099 85%,
										#00000022 95%,
										#00000000 100%);
								display: flex;
								padding: 12px;
								position: absolute;
								gap: 8px;
								align-items: flex-start;
								bottom: 0px;
							}

							/* Styles for the icon placeholder wrapper */
							.icon-container {
								border-radius: 100%;
								width: 3rem;
								height: 3rem;
								background-color: purple;
								flex-shrink: 0;
								margin-top: 2px;
							}

							/* Styles for the actual icon/avatar placeholder */
							.channel-icon {
								/*
								width: 100%;
								height: 100%;
								background-color: #ccc;
								border-radius: 100%;
								display: block;*/
							}

							/* Styles for the text details wrapper */
							.text-title-wrapper {

								/*
								flex-grow: 1;
								overflow: hidden;
							}

							/* Styles for the video title */
								.video-title {
									font-size: 1rem;
									font-weight: 600;
									margin: 0 0 4px 0;
									color: #ffffff;
								}

								/* Styles for the smaller detail text (Channel name and Date) */
								.video-details-text {
									color: #ffffff !important;
									font-size: 1em;
								}

								/* Styles for the paragraph elements inside details */
								.detail-p {
									/*
								margin: 0;
								padding: 0;
							*/
								}
						</style>
					</div>
				</fieldset>
				<fieldset>
					<button type="button" style="background-color:white; color:black !important; padding-top:0.3em;" onclick="

(async () =>{
    let streams;
    let channelData = {}; // Object to hold channel details (icons)

    try{
        // ASSUMING these functions return the necessary data
        streams = await window.monitorMessages.yt.GetAllUpcomingBroadcastsAndReturnJson();
    }
    catch(err){
        throw new Error('could not get streams!' + err);
    }

    console.log('found streams: \n' + streams);

    const d = document;
    
    // 1. COLLECT ALL UNIQUE CHANNEL IDs FOR BATCH FETCH
    const channelIds = new Set();
    streams.items.forEach(stream => {
        if (stream.snippet && stream.snippet.channelId) {
            channelIds.add(stream.snippet.channelId);
        }
    });

	/*
    // 2. FETCH CHANNEL ICONS (ASSUMING A BATCH FUNCTION EXISTS)
    if (channelIds.size > 0) {
        try {
            // NOTE: This assumes window.monitorMessages.yt has a function to fetch channel data based on IDs.
            const channelsResponse = await window.monitorMessages.yt.GetChannelThumbnailsAndReturnJson(Array.from(channelIds));
            
            // Map the channel response items to the channelData object for easy lookup
            channelsResponse.items.forEach(channel => {
                // Using 'default' thumbnail for a small icon
                const iconUrl = channel.snippet.thumbnails.default.url; 
                channelData[channel.id] = iconUrl;
            });
        } catch (err) {
            console.error('Could not fetch channel icons:', err);
        }
    }
	*/
    // --- End of icon fetching logic ---

    // Helper function to create elements with properties
    function CE(args = {
			elem:'div', 
			id:undefined, 
			class:undefined, 
			innerText:undefined, 
			innerHTML:undefined, 
			onclick:undefined, 
			src:undefined, 
			type:undefined
		}){
        let elem = d.createElement(args.elem);
        if (args.id) elem.id = args.id;
        if (args.class) elem.className = args.class; 
        if (args.innerText) elem.innerText = args.innerText;
        if (args.innerHTML) elem.innerHTML = args.innerHTML;
        if (args.onclick) elem.onclick = args.onclick;
        if (args.src) elem.src = args.src; 
        if (args.type) elem.type = args.type; 
        return elem;
    };
    
    // Get the element where streams will be displayed
    const streamSelectionContainer = d.getElementById('youtube-stream_selection');
    if (!streamSelectionContainer) {
        console.error('Target container \'youtube-stream_selection\' not found.');
        return;
    }
    
    // --- Minimal Styling & Clearing ---
    streamSelectionContainer.innerHTML = ''; 
    streamSelectionContainer.className = ''; 


    for(let i=0; i < streams.items.length; ++i){
        const stream = streams.items[i];
        if (!stream.id || !stream.id.videoId) continue; 
        
        let BROADCAST_ID = stream.id.videoId;
        let channelId = stream.snippet.channelId; 
        let videoTitleText = stream.snippet.title || 'Untitled Stream';
        let channelNameText = stream.snippet.channelTitle || 'Unknown Channel';
        let publishedDate = new Date(stream.snippet.publishedAt).toLocaleDateString('en-US', { year: 'numeric', month: 'short', day: 'numeric' });
        let thumbnailUrl = stream.snippet.thumbnails.high.url;
        let channelIconUrl = channelData[channelId] || ''; 
        
        // --- 1. container (Main Card) ---
        let container = CE({
            elem: 'div',
            id: BROADCAST_ID,
            class: 'stream-card', // CSS Class
        });

        // --- 2. thumbnailContainer ---
        let thumbnailContainer = CE({
            class: 'thumbnail-container', // CSS Class
        });

        // --- 2.1. thumbnail (Image) ---
        let thumbnail = CE({
            elem: 'img',
            src: thumbnailUrl,
            class: 'thumbnail-img', // CSS Class
        });
        
        // --- 2.2. selectionButton (Confirmation Overlay) ---
        let selectionButton = CE({
            elem: 'button',
            innerText: '‚úÖ Select',
            class: 'selection-button', // CSS Class
						type:'button',
            onclick: ((id) => (e) => {
                e.stopPropagation(); 
                
                d.getElementById('youtube-broadcastId').value = id;
                window.monitorMessages.yt.UpdateConfig({broadcastId: id});
                
                // --- Essential Highlighting Logic (border change) ---
                let elems = d.getElementById('youtube-stream_selection');
                for(let k = 0; k < elems.children.length; ++k){
                    const currentCard = elems.children[k];
                    const currentButton = currentCard.querySelector('.selection-button');

                    if(currentCard.id == id){
                        // Selected: Apply white border and clear background (if it was set)
                        currentCard.style.border = 'solid white 0.3rem'; 
                        currentCard.style.backgroundColor = ''; // Clear background highlight
                        if(currentButton) currentButton.style.opacity = '0';
                    } else {
                        // Unselected: Clear border and clear background
                        currentCard.style.border = ''; 
                        currentCard.style.backgroundColor = ''; 
                        if(currentButton) currentButton.style.opacity = '0';
                    }
                }
            })(BROADCAST_ID),
        });
        
        // Add hover effect logic (must remain in JS)
        container.onmouseover = (e) => {
            // Check if the card is already selected (has the white border)
            if (container.style.border.indexOf('solid white 0.3rem') === -1) {
                 selectionButton.style.opacity = '1';
            }
        };
        container.onmouseout = (e) => {
            selectionButton.style.opacity = '0';
        };


        // --- 3. infoContainer (Holds Icon and Text) ---
        let infoContainer = CE({
            class: 'info-container', // CSS Class
        });
        
        // --- 3.1. iconContainer ---
        let iconContainer = CE({
            class: 'icon-container', // CSS Class
        });

        // --- 3.1.1. icon (Actual Channel Image) ---
        let icon = CE({
            elem: 'img', 
            src: channelIconUrl, // Set the actual image source
            class: 'channel-icon', // CSS Class for size and border-radius
        });

        // --- 3.2. title (Holds all Text Details) ---
        let title = CE({
            class: 'text-title-wrapper', // CSS Class
        });

        // --- 3.2.1. videoTitle ---
        let videoTitle = CE({
            elem: 'h3',
            innerText: videoTitleText,
            class: 'video-title', // CSS Class
        });
        
        // --- 3.2.2. details (Date and Channel) ---
        let details = CE({
            class: 'video-details-text', // CSS Class
        });
        
        // --- 3.2.2.1. channelName ---
        let channelName = CE({
            elem: 'p',
            innerText: channelNameText,
            class: 'detail-p', // CSS Class
        });
        
        // --- 3.2.2.2. videoDate ---
        let videoDate = CE({
            elem: 'p',
            innerText: 'Scheduled: ' + publishedDate,
            class: 'detail-p', // CSS Class
        });


        // --- Assembly ---
        
        //iconContainer.appendChild(icon);
        
        details.appendChild(channelName);
        details.appendChild(videoDate);

        title.appendChild(videoTitle);
        title.appendChild(details);

        //infoContainer.appendChild(iconContainer);
        infoContainer.appendChild(title);
        
        thumbnailContainer.appendChild(thumbnail);
        thumbnailContainer.appendChild(selectionButton);

        container.appendChild(thumbnailContainer);
        container.appendChild(infoContainer);

        streamSelectionContainer.appendChild(container);
    }
})()
">
						get scheduled streams
					</button>
					<div>
						<label>select stream</label>
						<div id="youtube-stream_selection" style="">
							<span style="
							background-color:transparent;
							display: block;
							text-align:center;
							margin-top:3em;
							vertical-align:middle;
							width:100%;
						">
								<em>wizard not started yet</em>, fill api and channel name then try again
							</span>
						</div>
					</div>
					<div class="yt_form-input_container">
						<label>broadcastId</label>
						<input type="text">
					</div>
				</fieldset>
				<fieldset>
					<div class="yt_form-input_container">
						<label>liveChatId</label>
						<button type="button" style="background-color:white; color:black !important; padding-top:0.3em;" onclick='(async () => {
        try {
            // Corrected: Get the input element
            let liveChatIdInput = document.getElementById("youtube-liveChatId"); 
            liveChatIdInput.value = await window.monitorMessages.yt.GetLiveChatIdFromBroadcastId();

        } catch (error) {
            console.error("Error executing onclick function:", error);
        }
    })()'>
							get liveChatId
						</button>
						<input type="text">
					</div>
				</fieldset>
				<fieldset>
					<div class="yt_form-input_container">
						<label>debug (not wired yet)</label>
						<script>
							document.addEventListener('DOMContentLoaded', () => {
								// Wait for the button and the monitorMessages object to be available
								const button = document.getElementById('youtube-debug_toggle');
								if (button && window.monitorMessages && window.monitorMessages.yt) {
									button.innerText = window.monitorMessages.yt.debugMode;
								}
							});
						</script>

						<button type="button" id="youtube-debug_toggle" style="color:black !important;" onclick="(async ()=>{
        if(window.monitorMessages.yt.debugMode == true){
            window.monitorMessages.yt.debugMode = false;
            // CORRECTED SYNTAX HERE
            document.getElementById('youtube-debug_toggle').innerText = window.monitorMessages.yt.debugMode;
        }
        else{
            window.monitorMessages.yt.debugMode = true;
            document.getElementById('youtube-debug_toggle').innerText = window.monitorMessages.yt.debugMode;
        }
    })()">
							value has not been loaded
						</button>
					</div>
				</fieldset>
			</details>
			<!--
			<div style="max-width:60em; display:inline-block;">
				<p>provide the channel name and api key, then click here to let the wizard do the rest!</p>
				<button type="button" id="youtube-wizard" style="color:black !important; background-color: transparent; user-select:none;"
					id="youtube-wizard" type="disabled" value="fill the rest of the inputs!"
					onclick="() => {console.log('wizard clicked')}">
					wizard üßô‚Äç‚ôÇÔ∏è
				</button>
				<script type="module">
					document.addEventListener('DOMContentLoaded', async () => {
						let wizard = document.getElementById("youtube-wizard");

						wizard.addEventListener('mousedown', async () => {
							try {
								let id = "broadcastId";
								newConfigValues[id] = await window.monitorMessages.yt.GetBroadcastIdFromChannelId();
								document.getElementById("youtube-" + id).value = newConfigValues[id];
							}
							catch (err) {
								throw new Error("Could not get or update broadcastId \n", err);
							}

							try {
								let id = "liveChatId"
								newConfigValues["liveChatId"] = await window.monitorMessages.yt.GetLiveChatIdFromBroadcastId();
								document.getElementById("youtube-" + id).value = newConfigValues[id];


								// This replaces the logic that was previously failing on line 736
								// The poll function handles the waiting and retries automatically
								const liveChatId = await window.monitorMessages.yt.PollForLiveChatId();

								// Now you can safely use liveChatId, it's guaranteed to be active
								console.log("Live Chat ID is active and ready to use:", liveChatId);

							} catch (e) {
								// This catches the error if polling fails after all attempts
								console.error("Failed to initialize live chat connection:", e);
								// Throw the application-specific error that was caught
								throw new Error("Could not get or update liveChatId");
							}
						});
					});
				</script>
			</div>
-->
		</form>
		<script type="module">
			document.addEventListener('DOMContentLoaded', () => {
				console.log('Test result:', document.getElementById('youtube-config'));
				// -------------------------

				const form = document.getElementById('youtube-config');

				if (!form) {
					console.error("Form with ID 'youtube-config' not found.");
					return;
				}

				const containers = form.querySelectorAll('div');
				containers.forEach(container => {
					const label = container.querySelector('label');
					const input = container.querySelector('input');

					if (label && input) {
						const labelText = label.textContent.trim();
						const cleanedText = labelText
							.replace(/\s+/g, '-') // Replace spaces with hyphens
							.replace(/[^a-zA-Z0-9-]/g, ''); // Remove illegal ID characters

						const newId = 'youtube-' + cleanedText;
						input.id = newId;
						label.htmlFor = newId;
						console.log(`Assigned new ID: ${newId}`);
					}
				});
			});
		</script>
	</div>
	<hr>
	<div>
		<style>
			table {
				border: 0.2em solid white;
				text-align: left;
				max-width: 80em;
				width: 100%;
			}

			table>* {
				overflow-x: scroll;
			}

			table>th {
				max-width: 2em;
				text-align: center;
			}

			td,
			th {
				word-wrap: break-word;
				max-width: 40em;
			}

			/*
			td:nth-child(1),
			th:nth-child(1) {
				background-color: blue;
				word-wrap: break-word;
				max-width: 1em;
			}
			*/

			td:nth-child(3),
			th:nth-child(3) {
				word-wrap: break-word;
				max-width: 3em;
			}

			td:nth-child(4),
			th:nth-child(4) {
				word-wrap: break-word;
				max-width: 4em;
			}

			td:nth-child(5),
			th:nth-child(5) {
				word-wrap: break-word;
				max-width: 3em;
			}

			td:nth-child(6),
			th:nth-child(6) {
				word-wrap: break-word;
				max-width: 22em;
			}

			td:nth-child(7),
			th:nth-child(7) {
				word-wrap: break-word;
				max-width: 5em;
			}

			td:nth-child(8),
			th:nth-child(8) {
				word-wrap: break-word;
				max-width: 2em;
			}

			table:nth-child(11) {
				max-width: 2em;
			}
	
			/*
			th:nth-child(2n+1) {
				background-color: #222;
			}
			*/

			th {
				padding: 0.3em;
			}

			/*
			tr:nth-child(2n+1) {
				background-color: #222;
			}
			*/

			tr:nth-child(2n+1)>td {
				color: white;
			}

			/*
			tr:nth-child(2n+1)>td:nth-child(2n+1) {
				background-color: #333;
			}
			*/
		</style>
		<details>
			<summary>test tts and tts settings</summary>
			<div style="margin:1em 0;">
				<label for="ttsMessage">Message:</label><br>
				<textarea id="ttsMessage" rows="3" cols="50" placeholder="Enter a message..." style="color:white;"></textarea>
			</div>

			<div style="margin:1em 0;">
				<label for="ttsRate">Speed:</label>
				<input type="range" id="ttsRate" min="0.5" max="2" step="0.1" value="1">
				<span id="rateVal">1</span>
			</div>

			<div style="margin:1em 0;">
				<label for="ttsPitch">Pitch:</label>
				<input type="range" id="ttsPitch" min="0" max="2" step="0.1" value="1">
				<span id="pitchVal">1</span>
			</div>

			<div style="margin:1em 0;">
				<label for="ttsVoice">voice:</label>
				<input type="number" id="ttsVoice" placeholder="49" value="49">
			</div>

			<div>
				<label for="playDemoTTS">demo with current settings:</label>
				<button type="button" id="playDemoTTS" type="button">click me (ear warning)</button>
				<script type="module">
					document.getElementById("playDemoTTS").addEventListener("click", () => {
						console.log("demoing current tts default");

						function TtsMessage() {return document.getElementById("ttsMessage").value};
						function TtsVoice() {return document.getElementById("ttsVoice").value};
						function TtsRate() {return parseFloat(document.getElementById("ttsRate").value)};
						function TtsPitch() {return parseFloat(document.getElementById("ttsPitch").value)};

						// Get the available voices
						let voices = window.speechSynthesis.getVoices();

						// Find the voice object that matches the name
						let desiredVoice = voices[TtsVoice()];

						// Check if the voice was found and proceed
						if (desiredVoice) {
							let utter = new SpeechSynthesisUtterance(TtsMessage());
							utter.voice = desiredVoice;
							utter.rate = TtsRate();
							utter.pitch = TtsPitch();

							window.speechSynthesis.cancel();
							window.speechSynthesis.speak(utter);
						} else {
							console.error(`Voice '${TtsVoice()}' not found.`);
							// Optional: Fallback to the default voice if the specified one isn't available
							const utter = new SpeechSynthesisUtterance(TtsMessage());
							utter.rate = TtsRate();
							utter.pitch = TtsPitch();
							window.speechSynthesis.cancel();
							window.speechSynthesis.speak(utter);
						}
					});

					// Ensure voices are loaded before the button is clicked.
					// This event is crucial for the getVoices() method to return a non-empty array.
					window.speechSynthesis.onvoiceschanged = () => {
						// This event handler ensures the voice list is updated.
						// The code inside the click listener can now reliably find a voice.
						console.log("Speech synthesis voices have changed (and are likely loaded).");
					};		</script>
			</div>
		</details>

		<script type="module">
			// 1. Define function at the module level (not inside the 'load' listener)
			async function addMessageToTable() {
				const form = document.getElementById('messageForm');
				const tableBody = document.querySelector('#messagesTable tbody');

				if (!form || !tableBody) {
					console.error("Form or Table Body not found.");
					return;
				}

				const user = form.user.value;
				const message = form.message.value;
				const ttsFlags = form.tts_flags.value;

				if (!user || !message || !ttsFlags) {
					alert("Please fill in all required fields.");
					return;
				}

				const newIndex = tableBody.rows.length + 1;
				const date = new Date().toLocaleTimeString('en-US', {hour12: false});

				// 1. Create the new row
				const newRow = tableBody.insertRow();

				// 2. Insert cells with data and elements (10 columns total)
				newRow.insertCell().textContent = newIndex;
				newRow.insertCell().textContent = user;
				newRow.insertCell().textContent = date;
				newRow.insertCell().textContent = ttsFlags;
				newRow.insertCell().textContent = await window.monitorMessages.EvaluateMessageScore(message);
				newRow.insertCell().textContent = message;
				newRow.insertCell().innerHTML = '<button>Play</button>';
				newRow.insertCell().innerHTML = '<input type="checkbox" checked>';
				newRow.insertCell().innerHTML = '<button>Timeout</button>';
				newRow.insertCell().innerHTML = '<button>Block</button>';
				newRow.insertCell().innerHTML = '<button>Ban</button>';

				form.message.value = '';
				form.message.focus();
			}

			// NOTE: If you also have the 'exportTableToJson' function, define it here as well.

			// 2. Use DOMContentLoaded for listener attachment (Better than 'load')
			document.addEventListener('DOMContentLoaded', () => {
				const addButton = document.getElementById('addButton');

				if (addButton) {
					// 3. FIX: Pass the function reference (NO parentheses)
					addButton.addEventListener('click', addMessageToTable);
				} else {
					console.error("Button with ID 'addButton' not found. Check HTML.");
				}
			});

		</script>
		<details>
			<summary>messages</summary>
			<div>
				<h3>Add Test Message</h3>
				<form id="messageForm">
					<label for="user">User:</label>
					<input type="text" id="user" name="user" value="TestUser" required>

					<label for="message">Message:</label>
					<input type="text" id="message" name="message" value="Hello, world!" required>

					<label for="tts_flags">TTS Flags (JSON):</label>
					<input type="text" id="tts_flags" name="tts_flags" value='{"p":1.5,"r":0.8", "v": 50}' required>

					<button type="button" id="addButton">Add Message to Table</button>
				</form>

			</div>
			<div>
				<script>
					function exportTableToJson() {
						// 1. Get the table element
						const table = document.getElementById("messagesTable");
						if (!table) {
							console.error("Table with id 'messagesTable' not found.");
							return;
						}

						// 2. Extract header names (column names)
						// Assumes the first row is the header (<thead>)
						const headers = [];
						const headerRow = table.querySelector('thead tr') || table.rows[0];
						if (headerRow) {
							for (let i = 0; i < headerRow.cells.length; i++) {
								const cellText = headerRow.cells[i].textContent.trim();

								// Skip columns that are buttons or checkboxes (based on your column list)
								// You can adjust these indices if your table structure changes
								// The columns to skip are: play message, in tts que, time user out, block user from tts, ban user
								// These correspond to columns 5, 6, 7, 8, 9 (0-indexed)
								if (i < 5 || i === 6) {
									// Only include the text-based columns and the checkbox column 'in tts que'
									// For 'in tts que', we use the header name for consistency
									headers.push(cellText);
								}
							}
						} else {
							console.warn("Could not find a header row (<thead> or first <tr>). Using default keys.");
							// Fallback for missing header
							headers.push("index", "user", "date", "tts flags", "message");
						}


						// 3. Extract the row data
						const data = [];
						// Start from 1 to skip the header row, if no <thead> is used, otherwise iterate all <tr> in <tbody>
						const bodyRows = table.querySelector('tbody') ? table.querySelector('tbody').rows : Array.from(table.rows).slice(1);

						for (const row of bodyRows) {
							const rowData = {};
							let headerIndex = 0;

							for (let i = 0; i < row.cells.length; i++) {
								const cell = row.cells[i];

								// Skip the action/button columns (5, 7, 8, 9)
								if (i === 5 || i >= 7) {
									continue;
								}

								// Handle the Checkbox column: 'in tts que' (index 6)
								if (i === 6) {
									const checkbox = cell.querySelector('input[type="checkbox"]');
									const key = headers[headerIndex] || "in tts que";
									rowData[key] = checkbox ? checkbox.checked : false;
								}
								// Handle the JSON Object column: 'tts flags' (index 3)
								else if (i === 3) {
									const text = cell.textContent.trim();
									const key = headers[headerIndex] || "tts flags";
									try {
										// Attempt to parse the cell content as a JSON object
										rowData[key] = JSON.parse(text);
									} catch (e) {
										// If parsing fails, store as a string or a default empty object
										console.warn(`Could not parse JSON in 'tts flags' for row ${row.rowIndex}: ${text}`);
										rowData[key] = text;
									}
								}
								// Handle all other text/int columns (0, 1, 2, 4)
								else {
									const key = headers[headerIndex] || `col${i}`;
									rowData[key] = cell.textContent.trim();

									// Simple type conversion for 'index' column
									if (key === 'index' && !isNaN(parseInt(rowData[key]))) {
										rowData[key] = parseInt(rowData[key]);
									}
								}

								headerIndex++;
							}
							data.push(rowData);
						}

						// 4. Convert the data array to a JSON string
						const jsonString = JSON.stringify(data, null, 2); // 'null, 2' for pretty-printing

						// 5. Create a Blob and initiate download
						const blob = new Blob([jsonString], {type: "application/json"});
						const url = URL.createObjectURL(blob);

						const a = document.createElement("a");
						a.href = url;
						a.download = "messages_data.json"; // Suggested file name
						document.body.appendChild(a);
						a.click();
						document.body.removeChild(a);

						// Clean up the URL object
						URL.revokeObjectURL(url);
					}
				</script>
				<button type="button" onclick="exportTableToJson()">
					Export Table Data to JSON
				</button>
			</div>
		</details>


		<br>
		<br>

		<details>
			<summary>clip timestamps</summary>
			<table style="width:100%;">
				<tbody>
					<tr>
						<th>author</th>
						<th>message</th>
						<th>timestamp</th>
					</tr>
				</tbody>
			</table>
		</details>

		<details>
			<!--
		userData = {
			user1 = {
				points: int,
				warnings: [old -> new],
				isBanned: [old -> new],
				notes: char* []
			},
		}	
		-->
			<summary>users</summary>
			<table style="width:100%; max-height:60vh; overflow:scroll;">
				<tbody>
					<tr>
						<th>users</th>
						<th>points</th>
						<th>warnings</th>
						<th>banHistory</th>
						<th>notes</th>
					</tr>
				</tbody>
			</table>
		</details>
		<form>
			<style>
				#addProcessedMessageField>div {
					display: flex;
					flex-direction: row;
					justify-content: space-between;
					max-width: 30em;
				}
			</style>
			<details>
				<summary>add a processed message</summary>
				<fieldset id="addProcessedMessageField">
					<legend>add test message</legend>
					<div>
						<script>
							window.addEventListener('load', (async () => {
								// Helper function to create elements with properties (MUST BE DEFINED HERE)
								function CE(args = {elem: 'div', id: undefined, class: undefined, innerText: undefined, innerHTML: undefined, onclick: undefined, src: undefined, value: undefined}) {
									let elem = document.createElement(args.elem || 'div'); // Use 'div' as default
									if (args.id) elem.id = args.id;
									if (args.class) elem.className = args.class;
									if (args.innerText) elem.innerText = args.innerText;
									if (args.innerHTML) elem.innerHTML = args.innerHTML;
									if (args.onclick) elem.onclick = args.onclick;
									if (args.onkeyup) elem.onkeyup = args.onkeyup;
									if (args.src) elem.src = args.src;
									if (args.value) elem.value = args.value;
									return elem;
								};

								// 1. Define a function to wait for the object
								const waitForMonitorMessages = () => {
									return new Promise(resolve => {
										const check = () => {
											if (window.monitorMessages && window.monitorMessages.GetAndReturnEmptyMessageTemplate) {
												resolve(window.monitorMessages);
											} else {
												// Check every 50 milliseconds
												setTimeout(check, 50);
											}
										};
										check();
									});
								};

								try {
									let mm = await waitForMonitorMessages();
									let mT = await mm.GetAndReturnEmptyMessageTemplate();

									console.warn("Message Template:", JSON.stringify(mT));

									if (mT === undefined || mT === null) {
										throw new Error("GetAndReturnEmptyMessageTemplate returned undefined or null.");
									}

									let pmf = document.getElementById("addProcessedMessageField");
									if (!pmf) {
										console.error("Target container 'addProcessedMessageField' not found in the DOM.");
										return;
									}

									let container, label, input, key, value;
									const keys = Object.keys(mT);

									// Loop through keys and create inputs
									for (let i = 0; i < keys.length; ++i) {
										console.log("adding input");
										key = keys[i];
										value = mT[key]; // Assuming value is the default value or empty string

										container = CE({class: `processedMessageField-inputContainer`});

										// LABEL
										label = CE({elem: 'label', id: `processedMessageField-${key}`, innerText: key + ": "});
										container.appendChild(label);

										// INPUT (Assuming you want an input field)
										let defaultValue;
										switch (key) {
											case ("template_version"):
												defaultValue = "1";
												break;
											case ("authorName"):
												defaultValue = "webGUI-tester";
												break;
											case ("authorId"):
												defaultValue = "0000-0000-0000-0000";
												break;
											case ("streamOrigin"):
												defaultValue = "notLive";
												break;
											case ("date"):
												defaultValue = Date.now();
												break;
											case ("commands:"):
												defaultValue = "FIX ME BEFORE YOU USE ME";
												break;
											case ("processedMessage"):
												defaultValue = "";
												break;
											case ("platform:"):
												defaultValue = "webGUI";
												break;
											case ("rawMessage"):
												defaultValue = "Hello from the webGUI!";
												break;
											case ("score"):
												defaultValue = undefined;
												break;
											case ("isDeleted"):
												defaultValue = "false";
												break;
											default:
												defaultValue = "";
												break;
										}
										input = CE({elem: 'input', id: `processedMessageField-inputContainerFor${key}`, value: defaultValue, });

										container.appendChild(input);

										if (key == "processedMessage") {
											console.log("doing special stuff for the processed message");
											async function UpdateTestScoreStuff() {
												let shortestMaxMessage = 255;
												let input = document.getElementById("processedMessageField-inputContainerForprocessedMessage");
												let rcd = document.getElementById("processedMessageField-remainingCharsDisplay");
												let ms = document.getElementById("processedMessageField-score");
												let score = await window.monitorMessages.ScoreMessage(input.value);
												let scoreColor = await window.monitorMessages.ColorFromScoreValue(score);
												input.style.borderColor = scoreColor;
												rcd.innerText = String(input.value.length + "/" + shortestMaxMessage);
												if (shortestMaxMessage / input.value.length > 1) {rcd.style.color = "light-green !important";} // BUG: 
												else {rcd.style.color = "light-red";} // BUG: 
												ms.innerText = score;
												ms.style.borderColor = scoreColor; // BUG: 
											}
											input.onkeyup = UpdateTestScoreStuff;
											let rcd = CE({elem: "output", id: "processedMessageField-remainingCharsDisplay", });
											container.appendChild(rcd);
											let scoreDis = CE({elem: "output", id: "processedMessageField-score", });
											container.appendChild(scoreDis);
										}

										pmf.appendChild(container);
									}
									console.log("added all vars to page");
								} catch (error) {
									console.error("Initialization failed:", error);
								}
							}));

						</script>
						<!--
					<div>
						<input id="testMessage" type='text' style="width:90%;" onkeydown='UpdateTestScoreStuff();'
							onchange='UpdateTestScoreStuff()'>
					</div>
					<div style="display:flexbox; flex-direction:row;">
						<div style="display:inline-block;">
							<lable>char count:</lable>
							<output id="testMessage-remainingCharsDisplay">0/255</output>
						</div>
						<div style="display:inline-block;">
							<label>score:</label>
							<output id="testMessage-score">...</output>
						</div>
					</div>
					<div>
						<label>platform</label>
						<input type='text' value='system'>
					</div>
					<div>
						<label></label>
					</div>
-->
					</div>
				</fieldset>
			</details>
		</form>
		<div id="newMessagesTable">
			</div>
		<table id="messagesTable">
			<tbody>
				<tr>
					<!-- do not impliment this, 3 types of data rows are possible, whitelist: do nothing, graylist: make the row yellow, blacklist: check the "block user from tts" box -->
					<th>index</th> <!-- index of message -->
					<th>user</th> <!-- @ of user on youtube -->
					<th style="max-width:3em; overflow:hidden;">date</th> <!-- datetime of message -->
					<th style="max-width:3em;">tts flags</th>
					<!-- the 3 values that exist are: -r for rate, -v for voice, and -p for pitch -->
					<th>msg score</th>
					<th>message</th> <!-- the message -->
					<th>play message</th> <!-- the message -->
					<th>in tts que</th>
					<!-- is a checkbox, if message starts with: "!TTS", "!TIB", or "!BOT" automatically add -->
					<th>time user out</th> <!-- if clicked, will time user out for 10 minute-->
					<th>block user from tts</th>
					<th>ban user </th>
					<!-- when clicked, will ban the user from the channel, only after entering a special 6 digit pin (prompt the user for pin on click then do), -->
					<!-- is a checkbox, if checked messages from this user will not automatically be added to the tts queue -->
				</tr>
			</tbody>
		</table>

<div>
    <script>
        /**
         * Exports a JavaScript object as a downloaded JSON file.
         * @param {object} data - The JavaScript object to export.
         * @param {string} [filename='data.json'] - The desired name for the downloaded file.
         */
        function downloadJson(data, filename = 'data.json') {
            if (typeof data !== 'object' || data === null) {
                console.error("Invalid data provided. Must be a non-null object.");
                return;
            }

            try {
                // ... (downloadJson function body is unchanged)
                const jsonString = JSON.stringify(data, null, 2);
                const blob = new Blob([jsonString], {type: 'application/json'});
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;

                document.body.appendChild(a);
                a.click();

                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                console.log(`Successfully downloaded file: ${filename}`);

            } catch (error) {
                console.error("Failed to generate or download JSON file:", error);
            }
        }
    </script>
    <form>
        <div>
            <label>download unprocesed messages</label>
            <input type="button" value="download json" onclick="
                (async () => { // Corrected: wrapped in async function
                    console.log('getting all data');
                    downloadJson(await window.monitorMessages.GetAndReturnUnprocessedMessages(), `unprocessedMessages-${Date.now()}.json`)
                })();
            ">
        </div>
        <div>
            <label>download processed messages</label>
            <input type="button" value="download json" onclick="
                (async () => { // Corrected: wrapped in async function
                    console.log('getting all data');
                    downloadJson(await window.monitorMessages.GetAndReturnProcessedMessages(), `processedMessages-${Date.now()}.json`)
                })();
            ">
        </div>
        <div>
            <label>download user data</label>
            <input type="button" value="download json" onclick="
                (async () => { // Corrected: wrapped in async function
                    console.log('getting all data');
                    downloadJson(await window.monitorMessages.GetAndReturnUsers(), `userData-${Date.now()}.json`)
                })();
            ">
        </div>
        <div>
            <label>download all data</label>
            <input type="button" value="download json" onclick="
                (async () => { // Corrected: wrapped in async function
                    console.log('getting all data');
                    downloadJson(await window.monitorMessages.GetAndReturnUsers(), `userData-${Date.now()}.json`);
                    downloadJson(await window.monitorMessages.GetAndReturnProcessedMessages(), `processedMessages-${Date.now()}.json`);
                    downloadJson(await window.monitorMessages.GetAndReturnUnprocessedMessages(), `unprocessedMessages-${Date.now()}.json`);
                })();
            ">
        </div>
    </form>
</div>

</body>
