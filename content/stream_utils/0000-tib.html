<!-- 0000-tib.html -->
<!DOCTYPE html>
<html lang="en" style="margin-bottom:0;">

<head>
	<meta charset="UTF-8">
	<!-- https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP -->
	<!--<meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self';">-->
	<title>cockatiel | by @vulbyte</title>
	<script type="module" src="/client_management.js"></script>
	<script type="module">
		import PopUp from './tib_stuff/popup.js';
		window.PopUp = new PopUp();
		import MonitorMessages from './tib_stuff/monitorMessages.js';
		window.monitorMessages = new MonitorMessages();
		import YoutubeStuff from './tib_stuff/youtubeStuff.js';
		window.YoutubeStuff = new YoutubeStuff();
		import {assert} from './tib_stuff/assert.js';
		window.assert = assert;
		import {IntTimer} from './tib_stuff/intTimer.js';
		window.IntTimer = new IntTimer();
	</script>
</head>


<br>

<body style="">
	<script type="module">
		window.addEventListener('beforeunload', function (event) {
			// Check if there is unsaved data before showing the alert
			const hasUnsavedChanges = true; // Replace with your actual check (e.g., a boolean flag)

			if (hasUnsavedChanges) {
				// Cancel the event.
				event.preventDefault("the data has not been saved yet, please give me a sec to save the data!");

				// Chrome requires returnValue to be set.
				event.returnValue = 'the data base has not been backed up yet and will new values will not be saved!';

				// The actual text displayed to the user is determined by the browser
				// and is usually a standard message like "Are you sure you want to leave?"
				// You cannot customize the actual message shown in modern browsers.
			}
		});
	</script>
	<details>
		<summary>TiB config: click here to edit the cost of actions and defaults</summary>
		<div><label>voice:</label><input type="number" default="51"></div>
		<div><label>pitch:</label><input type="number" default="1.1"></div>
		<div><label>rate:</label><input type="number" default="0.9"></div>
		<div><label>soundboard cost:</label><input type="number" value="1000"></div>
		<div><label>tts cost:</label><input type="number" value="3000"></div>
	</details>

	<details>
		<summary>messageScoreChecker</summary>
		<div>
			<lavel>score:</lavel>
			<output id="messageScoreTest">0</output>
		</div>
		<textarea id="messageScoreCheck"></textarea>
		<script type="module">
			window.addEventListener('load', () => {

				let testArea = document.getElementById("messageScoreCheck");
				let messageScore = document.getElementById("messageScoreTest");

				let data;
				console.log("adding score checker listener");
				testArea.addEventListener("change", (e) => {
					window.monitorMessages.ScoreMessage(testArea.value)
						.then((res) => {
							console.log("calcing score")
							data = res;
							console.log(data);
							messageScore.innerText = data;
						});
				});
			});
		</script>
	</details>
	<!-- {{{7 chats to monitor -->
	<div style="
			background-color: #000; /* Example background color */
			border-top: solid white 0.1em;
			bottom: 0;
			color: var(--color_primary); /* Example text color */
			display:flex;
			justify-content: space-between;
			left: 0;
			padding-top: 0.5em;
			position: fixed;
			text-align: center;
			height:min-content;
			width: 100%;
		"> <!-- this group is for the controls stuck to the bottom of the screen -->
		<style>
			#enabled_streams {
				display: flex;
				justify-content: space-evenly;
				width: min-content;
			}

			#enabled_streams>div {
				border-radius: 1em;
				background-color: var(--color_primary);
				display: flex;
				justify-content: center;
				margin-bottom: 0.8em;
				padding: 0.2em;
			}
		</style>
		<div style="width:10%; display:flex; flex-direction:column; justify-content:space-between;">
			<label>chats to monitor</label>
			<div id='enabled_streams'>
				<style>
					:root {
						--icon_size: 1.4em;
					}

					#enabled_streams svg {
						height: calc(var(--icon_size)*.9);
						width: calc(var(--icon_size)*.9);
					}

					#enabled_streams>div {
						height: var(--icon_size);
						width: var(--icon_size);
					}
				</style>
				<div id="facebook_enabled" style='background-color:#550000' checked="false"><label><svg
							xmlns="http://www.w3.org/2000/svg" viewBox="0 0 36 36" fill="url(#facebook__a)" height="40" width="40">
							<defs>
								<linearGradient x1="50%" x2="50%" y1="97.078%" y2="0%" id="facebook__a">
									<stop offset="0%" stop-color="#0062E0" />
									<stop offset="100%" stop-color="#19AFFF" />
								</linearGradient>
							</defs>
							<path
								d="M15 35.8C6.5 34.3 0 26.9 0 18 0 8.1 8.1 0 18 0s18 8.1 18 18c0 8.9-6.5 16.3-15 17.8l-1-.8h-4l-1 .8z" />
							<path fill="#FFF"
								d="m25 23 .8-5H21v-3.5c0-1.4.5-2.5 2.7-2.5H26V7.4c-1.3-.2-2.7-.4-4-.4-4.1 0-7 2.5-7 7v4h-4.5v5H15v12.7c1 .2 2 .3 3 .3s2-.1 3-.3V23h4z" />
						</svg></label></div>
				<div id="twitch_enabled" style='background-color:#550000' checked="false"><label><svg
							xmlns="http://www.w3.org/2000/svg" xml:space="preserve" viewBox="0 0 2400 2800">
							<path fill="#fff" d="m2200 1300-400 400h-400l-350 350v-350H600V200h1600z" />
							<g fill="#9146ff">
								<path
									d="M500 0 0 500v1800h600v500l500-500h400l900-900V0H500zm1700 1300-400 400h-400l-350 350v-350H600V200h1600v1100z" />
								<path d="M1700 550h200v600h-200zm-550 0h200v600h-200z" />
							</g>
						</svg></label> </div>
				<div id="twitter_enabled" style='background-color:#550000' checked="false"><label><svg viewBox="0 0 256 209"
							width="256" height="209" xmlns="http://www.w3.org/2000/svg" preserveAspectRatio="xMidYMid">
							<path
								d="M256 25.45c-9.42 4.177-19.542 7-30.166 8.27 10.845-6.5 19.172-16.793 23.093-29.057a105.183 105.183 0 0 1-33.351 12.745C205.995 7.201 192.346.822 177.239.822c-29.006 0-52.523 23.516-52.523 52.52 0 4.117.465 8.125 1.36 11.97-43.65-2.191-82.35-23.1-108.255-54.876-4.52 7.757-7.11 16.78-7.11 26.404 0 18.222 9.273 34.297 23.365 43.716a52.312 52.312 0 0 1-23.79-6.57c-.003.22-.003.44-.003.661 0 25.447 18.104 46.675 42.13 51.5a52.592 52.592 0 0 1-23.718.9c6.683 20.866 26.08 36.05 49.062 36.475-17.975 14.086-40.622 22.483-65.228 22.483-4.24 0-8.42-.249-12.529-.734 23.243 14.902 50.85 23.597 80.51 23.597 96.607 0 149.434-80.031 149.434-149.435 0-2.278-.05-4.543-.152-6.795A106.748 106.748 0 0 0 256 25.45"
								fill="#55acee" />
						</svg></label> </div>
				<div id="youtube_enabled" style='background-color:#550000' checked="false"><label><svg viewBox="0 0 256 180"
							width="256" height="180" xmlns="http://www.w3.org/2000/svg" preserveAspectRatio="xMidYMid">
							<path
								d="M250.346 28.075A32.18 32.18 0 0 0 227.69 5.418C207.824 0 127.87 0 127.87 0S47.912.164 28.046 5.582A32.18 32.18 0 0 0 5.39 28.24c-6.009 35.298-8.34 89.084.165 122.97a32.18 32.18 0 0 0 22.656 22.657c19.866 5.418 99.822 5.418 99.822 5.418s79.955 0 99.82-5.418a32.18 32.18 0 0 0 22.657-22.657c6.338-35.348 8.291-89.1-.164-123.134Z"
								fill="red" />
							<path fill="#FFF" d="m102.421 128.06 66.328-38.418-66.328-38.418z" />
						</svg></label></div>
			</div>
		</div>
		<script type='module'>
			window.addEventListener('DOMContentLoaded', () => {
				console.log('making the buttons fancy')
				let elem = document.getElementById('enabled_streams')

				for (let i = elem.children.length - 1; i >= 0; --i) {
					let child = elem.children[i];
					let default_color = child.style.backgroundColor;
					//below was for enabled/disabled text, no longer needed
					//child.id = child.children[0].innerText.slice(0, child.children[0].innerText.indexOf(':')) + '_button';
					child.setAttribute('checked', false);
					child.style.backgroundColor = '#550000' //`color-mix(in oklab, (${default_color}, rgb(0,0,0)))`

					child.style.userSelect = 'none';
					child.addEventListener('click', (e) => {
						console.log('platform toggle clicked');
						if (child.getAttribute('checked') == 'true') {
							console.log('setting false');
							child.setAttribute('checked', false);
							child.style.backgroundColor = '#550000';
						}
						else {
							console.log('setting true');
							child.setAttribute('checked', true);
							child.style.backgroundColor = '#005500';
						}
					});
				}
			});
		</script>
		<!-- }}}7 -->

		<!-- {{{7 -->
		<div style="display:flex; flex-direction:column;">
			<button id="sai" style="background-color:lightgreen;">save all inputs</button>
			<button id="lai" style="background-color:powderblue;">load all inputs</button>
			<script type="module">
				window.addEventListener('DOMContentLoaded', (e) => {
					let sai = document.getElementById("sai");
					let lai = document.getElementById("lai");

					let inputs = document.getElementsByTagName("input");
					let input;
					sai.addEventListener("click", (e) => {
						console.log("saving inputs");
						for (let i = 0; i < inputs.length; ++i) {
							input = inputs[i];
							localStorage.setItem(String(input.id), input.value);
						}
					});

					lai.addEventListener("click", (e) => {
						console.log("loading inputs");
						for (let i = 0; i < inputs.length; ++i) {
							try {
								input = inputs[i];
								input.value = localStorage.getItem(String(input.id));
							}
							catch (err) {
								console.log("unable to assign value:\n" + input[i] + "\n" + err);
							}
						}
					});
				});
			</script>
		</div>
		<!-- }}}7 -->

		<!-- {{{7 start/stop functions -->
		<style>
			#function_buttons {
				width: 16em;
				display: flex;
				flex-direction: column;
				padding-top: 0.7em;
			}

			#function_buttons>div {
				margin: 0px;
				padding: 0px;
			}

			#function_buttons>*>button {
				margin: auto;
				width: 12em;
			}
		</style>
		<div id='function_buttons'>
			<button id='start_monitoring_button' style='background-color: darkgreen;' onload="(()=>(
						window.AddEventListener('DOMContentLoaded', () => {
							document.getElementById('start_monitoring_button').addEventListener('click', () => {
								console.log('start_monitoring_button clicked');
								window.monitorMessages.StartMonitoring()
						})
					))()">start monitoring </button>
			<button id='stop_monitoring_button' style='background-color: darkred;'
				onclick="window.monitorMessages.StopMonitoring()">stop monitoring</button>
		</div>
		<!-- {{{7 start/stop + auto tts functions -->
		<style>
			#function_buttons {
				width: 16em;
				display: flex;
				flex-direction: column;
				padding-top: 0.7em;
			}

			#function_buttons>div {
				margin: 0px;
				padding: 0px;
			}

			#function_buttons>*>button {
				margin: auto;
				width: 12em;
			}
		</style>
		<div id='function_buttons'>
			<button id='start_tts_button' style='background-color: darkblue; color: white;'>start auto tts</button>
			<button id='pause_tts_button' style='background-color: goldenrod;'>pause auto tts</button>
			<br>
			<label for="timeout_duration">timeout duration (seconds)</label>
			<input id="timeout_duration" type="number" value="300" min="10" step="10" />
		</div>
		<script type='module'>
			import {IntTimer} from "./tib_stuff/intTimer.js";
			window.addEventListener('DOMContentLoaded', () => {
				//add update for on change to re-init the timer				
				let ttsTimer = new IntTimer({
					name: "ttsTimer",
					timeoutDuration: document.getElementById("timeout_duration").value, // This is a DOM element!
					timeoutListeners: [ReadNextTts],
					debugMode: true,
				});

				document.getElementById("timeout_duration").addEventListener("change", () => {
					//window.PopUp({"message": "turn off tts first!"});
					ttsTimer.timeoutDuration = document.getElementById("timeout_duration").value;
					ttsTimer.Restart();
				})

				function ReadNextTts() {
					console.log("ReadNextTts function called!");

					let table = document.getElementById("messagesTable");

					if (!table) {
						console.log("messagesTable not found");
						return;
					}

					console.log(`Table has ${table.rows.length} rows`);

					// Debug: Check what's in each row
					for (let i = 0; i < table.rows.length; ++i) {
						let row = table.rows[i];
						console.log(`Row ${i} has ${row.cells.length} cells`);

						// Check if cell 6 exists and what type of element it is
						if (row.cells[6]) {
							console.log(`Row ${i}, cell 6 exists:`, row.cells[6]);
							console.log(`Row ${i}, cell 6 innerHTML:`, row.cells[6].innerHTML);

							// Check if it's a checkbox
							let checkbox = row.cells[6].querySelector('input[type="checkbox"]');
							if (checkbox) {
								console.log(`Row ${i}, checkbox found, checked: ${checkbox.checked}`);
								if (checkbox.checked) {
									checkbox.checked = false;
									console.log(`Pressing button in row ${i}`);
									row.cells[5].children[0].click();
									break;
								}
							} else {
								// Maybe the checkbox IS the cell content?
								if (row.cells[6].type === 'checkbox') {
									console.log(`Row ${i}, cell 6 IS a checkbox, checked: ${row.cells[6].checked}`);
									if (row.cells[6].checked) {
										row.cells[6].checked = false;
										console.log(`Pressing button in row ${i}`);
										row.cells[5].children[0].click();
										break;
									}
								} else {
									console.log(`Row ${i}, cell 6 is not a checkbox:`, row.cells[6].tagName);
								}
							}
						} else {
							console.log(`Row ${i}, cell 6 does not exist`);
						}
					}

					console.log("ReadNextTts function finished");
				}// unique input 

				// ############################################################
				// imports from window
				// ############################################################
				const PopUp = window.PopUp;
				const assert = window.assert;
				console.log('monitor buttons script loaded');

				// ############################################################
				// helper to update button states
				// ############################################################
				function setButtonStates({monitoring}) {
					const startBtn = document.getElementById('start_monitoring_button');
					const stopBtn = document.getElementById('stop_monitoring_button');

					if (monitoring) {
						startBtn.disabled = true;
						startBtn.style.opacity = '0.5';
						startBtn.textContent = 'monitoring...';

						stopBtn.disabled = false;
						stopBtn.style.opacity = '1';
						stopBtn.textContent = 'stop monitoring';
					} else {
						startBtn.disabled = false;
						startBtn.style.opacity = '1';
						startBtn.textContent = 'start monitoring';

						stopBtn.disabled = true;
						stopBtn.style.opacity = '0.5';
						stopBtn.textContent = 'stop monitoring';
					}
				}

				// ############################################################
				// initialize buttons on page load
				// ############################################################
				window.addEventListener('DOMContentLoaded', () => {
					console.log('Button states initialized');
				});
			});
		</script>
		<!-- }}}7 -->

		<!-- {{{7 updates -->
		<style>
			:root {
				--guage_size: 2em;
			}

			.guage {
				/* This is the outer circle, acting as the background track */
				height: calc(var(--guage_size) * 1);
				width: calc(var(--guage_size) * 1);
				border-radius: 50%;
				background: conic-gradient(#ff0 0%,
						#f0f 33%,
						#0ff 66%,
						#ff0 100%);
				position: relative;
				/* Needed for positioning the inner circle */
				display: grid;
				place-items: center;
				cursor: default;
			}

			.guage_mask {
				background: conic-gradient(transparent 0%,
						transparent 80%,
						#000 80%,
						#000 100%);
				position: absolute;
				border-radius: 50%;
				top: 50%;
				left: 50%;
				transform: translate(-50%, -50%) rotate(-145deg);
				height: calc(var(--guage_size) * 1.1);
				width: calc(var(--guage_size) * 1.1);
				z-index: 99;
			}

			.guage::after {
				content: "";
				display: block;
				position: absolute;
				height: calc(var(--guage_size) * 0.7);
				width: calc(var(--guage_size) * 0.7);
				border-radius: 50%;
				background-color: black;
				top: 50%;
				left: 50%;
				transform: translate(-50%, -50%);
			}

			.guage-inner {
				position: absolute;
				top: 50%;
				left: 50%;
				transform: translate(-50%, -50%);
				font-size: calc(var(--guage_size)*0.3);
				z-index: 100;
			}

			#update_info>div {
				display: flex;
				justify-content: space-between;
				padding-left: 1em;
				padding-right: 1em;
			}

			#update_info :nth-child(1) {}

			#update_info>div:nth-child(2)>label,
			#update_info>div:nth-child(2)>span {
				color: color-mix(in oklab, #f0f, white);
			}

			#update_info>div:nth-child(3)>label,
			#update_info>div:nth-child(3)>span {
				color: color-mix(in oklab, #ff0, white);
			}

			#update_info>div:nth-child(4)>label,
			#update_info>div:nth-child(4)>span {
				color: color-mix(in oklab, #0ff, white);
			}
		</style>
		<!--
		<div id="update_info" style="
				border:solid white 0.1em;
				display:flex;  
				flex-direction:column;
				margin:0.2em;
				padding:0.2em;
				text-align:left; 
				width:16em; 
		">
			<div>
				<label>next update:</label>
				<div class="guage">
					<div class="guage_mask"></div>
					<div class="guage-inner">
						<span>164</span>
					</div>
				</div>
			</div>
			<div><label>tts queue:</label><span>999</span>
			</div>
			<div><label>tts messages read:</label><span>1000</span>
			</div>
			<div><label>total messages:</label><span>9999</span>
			</div>
		</div>
-->
		<!-- }}}7 -->
	</div>

	<hgroup style="display:flex; justify-content:space-around;">
		<!--<img style="max-height:100%; width:3em;" src="./non-code_assets/cockatiel_logo.png">-->
		<h1>cockatiel</h1>
		<h6>by vulbyte</h6>
		<img style="max-height:100%; width:3em;"
			src='https://raw.githubusercontent.com/vulbyte/vulbyteDotCom/0b0fcb64b46a2665d622ce094517332ab6b6cb7f/assets/dev_icon.svg'>
	</hgroup>

	<div>
		<form id="upload_form">
			<div>
				<label>load unprocessed message</label>
				<input type="file">
			</div>
			<div>
				<label>load processed message</label>
				<input type="file">
			</div>
			<div>
				<label>load users data</label>
				<input type="file">
				<button </div>
					<div>
						<button onclick='(()=>(
				let uf = document.getElementById("upload_form");
				let data = new FormData(uf);
				data = Object.fromEnteries(data);

				window.monitorMessages.AddMessa
			))()'>
							load data into system
						</button>
					</div>
		</form>
	</div>

	<div>
		<h2>stream info</h2>
		<div style='margin:auto; width: 80%;'>

			<style>
				#new_list {
					width: 80%;
				}

				#new_list>li {
					display: flex;
					justify-content: space-between;
					margin: auto;
					width: 89%;
				}

				#new_list>li>div {
					padding-bottom: 0px;
					margin-bottom: 0px;
				}

				#new_list>li>div>* {
					margin-right: 0.5em;
				}

				#new_list>li>label {
					padding-top: 0.7em;
				}

				#youtube_settings>li>div {
					margin-bottom: 0px;
					padding-bottom: 0px;
				}
			</style>

			<br>

		</div>

	</div>
	<div>
		<style>
			#youtube-config,
			#youtube-config>*,
			#youtube-config>*>*,
			#youtube-config>*>*>*,
			#youtube-config>*>*>*>* {
				background-color: #ff000022;
				color: #ddd !important;
				font-family: Helvetica, sans-serif, Arial !important;
				border-radius: 0.5em;
				padding-bottom: 0.3em;
			}

			.yt_form-input_container {
				display: flex;
				flex-direction: column;
			}

			.yt_form-input_container>label {
				display: inline-block;
				width: 8em;
			}

			.yt_form-input_container>input {}
		</style>
		<form id="youtube-config">
			<details>
				<summary>youtube specific config</summary>
				<fieldset>
					<legend>public info</legend>
					<div class="yt_form-input_container">
						<label>channelName</label>
						<input type="text">
					</div>
					<div class="yt_form-input_container">
						<label>apiKey</label>
						<em>DO NOT SHARE THIS OR YOU COULD GET BANNED</em>
						<input type="password">
						<aside>this value will not have a toggle visable option to prevent leaks</aside>
					</div>
					<div class="yt_form-input_container">
						<label>channelId</label>
						<button type="button" style="background-color:white; color:black !important; padding-top:0.3em;" onclick='(async () => {
								console.log("getting youtube-channelId!");
								let api = document.getElementById("youtube-apiKey"); 
								let channelName = document.getElementById("youtube-channelName"); 

								if (!api || !channelName || !channelName.value.trim()) {
									console.warn("youtube-wizard triggered in an invalid state"); 
									return;
								}; 

								let newConfigValues = {}; 
								let id = "channelId"; 

								try { 
									// 1. Await the promise returned by the getter function
									const channelIdResult = await window.monitorMessages.yt.GetChannelIdFromChannelName(channelName.value.trim());

									// 2. Assign the result to the config object
									newConfigValues[id] = channelIdResult;

									if (!newConfigValues[id]) {
										// Check if the result is valid
										throw new Error("Failed to retrieve a valid channel ID.");
									}

									// 3. Await the config update call
									await window.monitorMessages.yt.UpdateConfig(newConfigValues); 

									// 4. Update the UI
									document.getElementById("youtube-" + id).value = newConfigValues[id]; 

								} catch (err) { 
									console.error("Originalame error:", err);
									alert("Could not get or update channelId: " + (err.message || "Unknown error."));
									// We re-throw or handle the error, avoiding the direct unspecific throw
								}
							})()'>
							click to get channelId
						</button>
						<input type="text">
						<style>
							/* Styles for the main container wrapping all streams */
							#youtube-stream_selection {
								color: white;
								display: grid;
								grid-template-columns: repeat(auto-fit, minmax(10em, 1fr));
								gap: 0.8em;
								padding: 1em;
								background-color: black;
							}

							/* Styles for a single stream container (Card) */
							.stream-card {
								/*
								height: 18rem;
								width: 32em;*/
								aspect-ratio: 1.5/1;
								border-radius: 1rem;
								position: relative;
								cursor: pointer;
								background-color: #fff;
								overflow: hidden;
							}

							/* Styles for the section holding the thumbnail and button */
							.thumbnail-container {
								/*
								position: relative;
								width: 90%;
								height: 180px;
								overflow: hidden;*/
							}

							/* Styles for the thumbnail image */
							.thumbnail-img {
								position: absolute;
								width: 100%;
								height: 100%;
								object-fit: cover;
								display: block;
							}

							/* Styles for the selection button overlay */
							.selection-button {
								position: absolute;
								top: 0;
								left: 0;
								width: 100%;
								height: 100%;
								background-color: #000000AA;
								color: white;
								font-size: 1.5em;
								border: none;
								cursor: pointer;
								opacity: 1;
								transition: opacity 0.2s;
								z-index: 10;
								border-radius: 0px;
							}

							.selection-button:hover {
								background-color: #000000CC;
							}

							/* Styles for the area below the thumbnail (Icon and Text) */
							.info-container {
								background-image: linear-gradient(0deg,
										#00000099 0%,
										#00000099 85%,
										#00000022 95%,
										#00000000 100%);
								display: flex;
								padding: 12px;
								position: absolute;
								gap: 8px;
								align-items: flex-start;
								bottom: 0px;
							}

							/* Styles for the icon placeholder wrapper */
							.icon-container {
								border-radius: 100%;
								width: 3rem;
								height: 3rem;
								background-color: purple;
								flex-shrink: 0;
								margin-top: 2px;
							}

							/* Styles for the actual icon/avatar placeholder */
							.channel-icon {
								/*
								width: 100%;
								height: 100%;
								background-color: #ccc;
								border-radius: 100%;
								display: block;*/
							}

							/* Styles for the text details wrapper */
							.text-title-wrapper {

								/*
								flex-grow: 1;
								overflow: hidden;
							}

							/* Styles for the video title */
								.video-title {
									font-size: 1rem;
									font-weight: 600;
									margin: 0 0 4px 0;
									color: #ffffff;
								}

								/* Styles for the smaller detail text (Channel name and Date) */
								.video-details-text {
									color: #ffffff !important;
									font-size: 1em;
								}

								/* Styles for the paragraph elements inside details */
								.detail-p {
									/*
								margin: 0;
								padding: 0;
							*/
								}
						</style>
					</div>
				</fieldset>
				<fieldset>
					<button type="button" style="background-color:white; color:black !important; padding-top:0.3em;" onclick="

(async () =>{
    let streams;
    let channelData = {}; // Object to hold channel details (icons)

    try{
        // ASSUMING these functions return the necessary data
        streams = await window.monitorMessages.yt.GetAllUpcomingBroadcastsAndReturnJson();
    }
    catch(err){
        throw new Error('could not get streams!' + err);
    }

    console.log('found streams: \n' + streams);

    const d = document;
    
    // 1. COLLECT ALL UNIQUE CHANNEL IDs FOR BATCH FETCH
    const channelIds = new Set();
    streams.items.forEach(stream => {
        if (stream.snippet && stream.snippet.channelId) {
            channelIds.add(stream.snippet.channelId);
        }
    });

	/*
    // 2. FETCH CHANNEL ICONS (ASSUMING A BATCH FUNCTION EXISTS)
    if (channelIds.size > 0) {
        try {
            // NOTE: This assumes window.monitorMessages.yt has a function to fetch channel data based on IDs.
            const channelsResponse = await window.monitorMessages.yt.GetChannelThumbnailsAndReturnJson(Array.from(channelIds));
            
            // Map the channel response items to the channelData object for easy lookup
            channelsResponse.items.forEach(channel => {
                // Using 'default' thumbnail for a small icon
                const iconUrl = channel.snippet.thumbnails.default.url; 
                channelData[channel.id] = iconUrl;
            });
        } catch (err) {
            console.error('Could not fetch channel icons:', err);
        }
    }
	*/
    // --- End of icon fetching logic ---

    // Helper function to create elements with properties
    function CE(args = {
			elem:'div', 
			id:undefined, 
			class:undefined, 
			innerText:undefined, 
			innerHTML:undefined, 
			onclick:undefined, 
			src:undefined, 
			type:undefined
		}){
        let elem = d.createElement(args.elem);
        if (args.id) elem.id = args.id;
        if (args.class) elem.className = args.class; 
        if (args.innerText) elem.innerText = args.innerText;
        if (args.innerHTML) elem.innerHTML = args.innerHTML;
        if (args.onclick) elem.onclick = args.onclick;
        if (args.src) elem.src = args.src; 
        if (args.type) elem.type = args.type; 
        return elem;
    };
    
    // Get the element where streams will be displayed
    const streamSelectionContainer = d.getElementById('youtube-stream_selection');
    if (!streamSelectionContainer) {
        console.error('Target container \'youtube-stream_selection\' not found.');
        return;
    }
    
    // --- Minimal Styling & Clearing ---
    streamSelectionContainer.innerHTML = ''; 
    streamSelectionContainer.className = ''; 


    for(let i=0; i < streams.items.length; ++i){
        const stream = streams.items[i];
        if (!stream.id || !stream.id.videoId) continue; 
        
        let BROADCAST_ID = stream.id.videoId;
        let channelId = stream.snippet.channelId; 
        let videoTitleText = stream.snippet.title || 'Untitled Stream';
        let channelNameText = stream.snippet.channelTitle || 'Unknown Channel';
        let publishedDate = new Date(stream.snippet.publishedAt).toLocaleDateString('en-US', { year: 'numeric', month: 'short', day: 'numeric' });
        let thumbnailUrl = stream.snippet.thumbnails.high.url;
        let channelIconUrl = channelData[channelId] || ''; 
        
        // --- 1. container (Main Card) ---
        let container = CE({
            elem: 'div',
            id: BROADCAST_ID,
            class: 'stream-card', // CSS Class
        });

        // --- 2. thumbnailContainer ---
        let thumbnailContainer = CE({
            class: 'thumbnail-container', // CSS Class
        });

        // --- 2.1. thumbnail (Image) ---
        let thumbnail = CE({
            elem: 'img',
            src: thumbnailUrl,
            class: 'thumbnail-img', // CSS Class
        });
        
        // --- 2.2. selectionButton (Confirmation Overlay) ---
        let selectionButton = CE({
            elem: 'button',
            innerText: '‚úÖ Select',
            class: 'selection-button', // CSS Class
						type:'button',
            onclick: ((id) => (e) => {
                e.stopPropagation(); 
                
                d.getElementById('youtube-broadcastId').value = id;
                window.monitorMessages.yt.UpdateConfig({broadcastId: id});
                
                // --- Essential Highlighting Logic (border change) ---
                let elems = d.getElementById('youtube-stream_selection');
                for(let k = 0; k < elems.children.length; ++k){
                    const currentCard = elems.children[k];
                    const currentButton = currentCard.querySelector('.selection-button');

                    if(currentCard.id == id){
                        // Selected: Apply white border and clear background (if it was set)
                        currentCard.style.border = 'solid white 0.3rem'; 
                        currentCard.style.backgroundColor = ''; // Clear background highlight
                        if(currentButton) currentButton.style.opacity = '0';
                    } else {
                        // Unselected: Clear border and clear background
                        currentCard.style.border = ''; 
                        currentCard.style.backgroundColor = ''; 
                        if(currentButton) currentButton.style.opacity = '0';
                    }
                }
            })(BROADCAST_ID),
        });
        
        // Add hover effect logic (must remain in JS)
        container.onmouseover = (e) => {
            // Check if the card is already selected (has the white border)
            if (container.style.border.indexOf('solid white 0.3rem') === -1) {
                 selectionButton.style.opacity = '1';
            }
        };
        container.onmouseout = (e) => {
            selectionButton.style.opacity = '0';
        };


        // --- 3. infoContainer (Holds Icon and Text) ---
        let infoContainer = CE({
            class: 'info-container', // CSS Class
        });
        
        // --- 3.1. iconContainer ---
        let iconContainer = CE({
            class: 'icon-container', // CSS Class
        });

        // --- 3.1.1. icon (Actual Channel Image) ---
        let icon = CE({
            elem: 'img', 
            src: channelIconUrl, // Set the actual image source
            class: 'channel-icon', // CSS Class for size and border-radius
        });

        // --- 3.2. title (Holds all Text Details) ---
        let title = CE({
            class: 'text-title-wrapper', // CSS Class
        });

        // --- 3.2.1. videoTitle ---
        let videoTitle = CE({
            elem: 'h3',
            innerText: videoTitleText,
            class: 'video-title', // CSS Class
        });
        
        // --- 3.2.2. details (Date and Channel) ---
        let details = CE({
            class: 'video-details-text', // CSS Class
        });
        
        // --- 3.2.2.1. channelName ---
        let channelName = CE({
            elem: 'p',
            innerText: channelNameText,
            class: 'detail-p', // CSS Class
        });
        
        // --- 3.2.2.2. videoDate ---
        let videoDate = CE({
            elem: 'p',
            innerText: 'Scheduled: ' + publishedDate,
            class: 'detail-p', // CSS Class
        });


        // --- Assembly ---
        
        //iconContainer.appendChild(icon);
        
        details.appendChild(channelName);
        details.appendChild(videoDate);

        title.appendChild(videoTitle);
        title.appendChild(details);

        //infoContainer.appendChild(iconContainer);
        infoContainer.appendChild(title);
        
        thumbnailContainer.appendChild(thumbnail);
        thumbnailContainer.appendChild(selectionButton);

        container.appendChild(thumbnailContainer);
        container.appendChild(infoContainer);

        streamSelectionContainer.appendChild(container);
    }
})()
">
						get scheduled streams
					</button>
					<div>
						<label>select stream</label>
						<div id="youtube-stream_selection" style="">
							<span style="
							background-color:transparent;
							display: block;
							text-align:center;
							margin-top:3em;
							vertical-align:middle;
							width:100%;
						">
								<em>wizard not started yet</em>, fill api and channel name then try again
							</span>
						</div>
					</div>
					<div class="yt_form-input_container">
						<label>broadcastId</label>
						<input type="text">
					</div>
				</fieldset>
				<fieldset>
					<div class="yt_form-input_container">
						<label>liveChatId</label>
						<button type="button" style="background-color:white; color:black !important; padding-top:0.3em;" onclick='(async () => {
        try {
            // Corrected: Get the input element
            let liveChatIdInput = document.getElementById("youtube-liveChatId"); 
            liveChatIdInput.value = await window.monitorMessages.yt.GetLiveChatIdFromBroadcastId();

        } catch (error) {
            console.error("Error executing onclick function:", error);
        }
    })()'>
							get liveChatId
						</button>
						<input type="text">
					</div>
				</fieldset>
				<fieldset>
					<div class="yt_form-input_container">
						<label>debug (not wired yet)</label>
						<script>
							document.addEventListener('DOMContentLoaded', () => {
								// Wait for the button and the monitorMessages object to be available
								const button = document.getElementById('youtube-debug_toggle');
								if (button && window.monitorMessages && window.monitorMessages.yt) {
									button.innerText = window.monitorMessages.yt.debugMode;
								}
							});
						</script>

						<button type="button" id="youtube-debug_toggle" style="color:black !important;" onclick="(async ()=>{
        if(window.monitorMessages.yt.debugMode == true){
            window.monitorMessages.yt.debugMode = false;
            // CORRECTED SYNTAX HERE
            document.getElementById('youtube-debug_toggle').innerText = window.monitorMessages.yt.debugMode;
        }
        else{
            window.monitorMessages.yt.debugMode = true;
            document.getElementById('youtube-debug_toggle').innerText = window.monitorMessages.yt.debugMode;
        }
    })()">
							value has not been loaded
						</button>
					</div>
				</fieldset>
			</details>
			<!--
			<div style="max-width:60em; display:inline-block;">
				<p>provide the channel name and api key, then click here to let the wizard do the rest!</p>
				<button id="youtube-wizard" style="color:black !important; background-color: transparent; user-select:none;"
					id="youtube-wizard" type="disabled" value="fill the rest of the inputs!"
					onclick="() => {console.log('wizard clicked')}">
					wizard üßô‚Äç‚ôÇÔ∏è
				</button>
				<script type="module">
					document.addEventListener('DOMContentLoaded', async () => {
						let wizard = document.getElementById("youtube-wizard");

						wizard.addEventListener('mousedown', async () => {
							try {
								let id = "broadcastId";
								newConfigValues[id] = await window.monitorMessages.yt.GetBroadcastIdFromChannelId();
								document.getElementById("youtube-" + id).value = newConfigValues[id];
							}
							catch (err) {
								throw new Error("Could not get or update broadcastId \n", err);
							}

							try {
								let id = "liveChatId"
								newConfigValues["liveChatId"] = await window.monitorMessages.yt.GetLiveChatIdFromBroadcastId();
								document.getElementById("youtube-" + id).value = newConfigValues[id];


								// This replaces the logic that was previously failing on line 736
								// The poll function handles the waiting and retries automatically
								const liveChatId = await window.monitorMessages.yt.PollForLiveChatId();

								// Now you can safely use liveChatId, it's guaranteed to be active
								console.log("Live Chat ID is active and ready to use:", liveChatId);

							} catch (e) {
								// This catches the error if polling fails after all attempts
								console.error("Failed to initialize live chat connection:", e);
								// Throw the application-specific error that was caught
								throw new Error("Could not get or update liveChatId");
							}
						});
					});
				</script>
			</div>
-->
		</form>
		<script type="module">
			document.addEventListener('DOMContentLoaded', () => {
				console.log('Test result:', document.getElementById('youtube-config'));
				// -------------------------

				const form = document.getElementById('youtube-config');

				if (!form) {
					console.error("Form with ID 'youtube-config' not found.");
					return;
				}

				const containers = form.querySelectorAll('div');
				containers.forEach(container => {
					const label = container.querySelector('label');
					const input = container.querySelector('input');

					if (label && input) {
						const labelText = label.textContent.trim();
						const cleanedText = labelText
							.replace(/\s+/g, '-') // Replace spaces with hyphens
							.replace(/[^a-zA-Z0-9-]/g, ''); // Remove illegal ID characters

						const newId = 'youtube-' + cleanedText;
						input.id = newId;
						label.htmlFor = newId;
						console.log(`Assigned new ID: ${newId}`);
					}
				});
			});
		</script>
	</div>
	<hr>
	<div>
		<style>
			table {
				border: 0.2em solid white;
				text-align: left;
				max-width: 80em;
				width: 100%;
			}

			table>* {
				overflow-x: scroll;
			}

			table>th {
				max-width: 2em;
				text-align: center;
			}

			td,
			th {
				word-wrap: break-word;
				max-width: 40em;
			}

			td:nth-child(1),
			th:nth-child(1) {
				background-color: blue;
				word-wrap: break-word;
				max-width: 1em;
			}

			td:nth-child(3),
			th:nth-child(3) {
				word-wrap: break-word;
				max-width: 3em;
			}

			td:nth-child(4),
			th:nth-child(4) {
				word-wrap: break-word;
				max-width: 4em;
			}

			td:nth-child(5),
			th:nth-child(5) {
				word-wrap: break-word;
				max-width: 3em;
			}

			td:nth-child(6),
			th:nth-child(6) {
				word-wrap: break-word;
				max-width: 22em;
			}

			td:nth-child(7),
			th:nth-child(7) {
				word-wrap: break-word;
				max-width: 5em;
			}

			td:nth-child(8),
			th:nth-child(8) {
				word-wrap: break-word;
				max-width: 2em;
			}

			table:nth-child(11) {
				max-width: 2em;
			}

			th:nth-child(2n+1) {
				background-color: #222;
			}

			th {
				padding: 0.3em;
			}

			tr:nth-child(2n+1) {
				background-color: #222;
			}

			tr:nth-child(2n+1)>td {
				color: white;
			}

			tr:nth-child(2n+1)>td:nth-child(2n+1) {
				background-color: #333;
			}
		</style>
		<details>
			<summary>test tts and tts settings</summary>
			<div style="margin:1em 0;">
				<label for="ttsMessage">Message:</label><br>
				<textarea id="ttsMessage" rows="3" cols="50" placeholder="Enter a message..." style="color:white;"></textarea>
			</div>

			<div style="margin:1em 0;">
				<label for="ttsRate">Speed:</label>
				<input type="range" id="ttsRate" min="0.5" max="2" step="0.1" value="1">
				<span id="rateVal">1</span>
			</div>

			<div style="margin:1em 0;">
				<label for="ttsPitch">Pitch:</label>
				<input type="range" id="ttsPitch" min="0" max="2" step="0.1" value="1">
				<span id="pitchVal">1</span>
			</div>

			<div style="margin:1em 0;">
				<label for="ttsVoice">voice:</label>
				<input type="number" id="ttsVoice" placeholder="49" value="49">
			</div>

			<div>
				<label for="playDemoTTS">demo with current settings:</label>
				<button id="playDemoTTS" type="button">click me (ear warning)</button>
				<script type="module">
					document.getElementById("playDemoTTS").addEventListener("click", () => {
						console.log("demoing current tts default");

						function TtsMessage() {return document.getElementById("ttsMessage").value};
						function TtsVoice() {return document.getElementById("ttsVoice").value};
						function TtsRate() {return parseFloat(document.getElementById("ttsRate").value)};
						function TtsPitch() {return parseFloat(document.getElementById("ttsPitch").value)};

						// Get the available voices
						let voices = window.speechSynthesis.getVoices();

						// Find the voice object that matches the name
						let desiredVoice = voices[TtsVoice()];

						// Check if the voice was found and proceed
						if (desiredVoice) {
							let utter = new SpeechSynthesisUtterance(TtsMessage());
							utter.voice = desiredVoice;
							utter.rate = TtsRate();
							utter.pitch = TtsPitch();

							window.speechSynthesis.cancel();
							window.speechSynthesis.speak(utter);
						} else {
							console.error(`Voice '${TtsVoice()}' not found.`);
							// Optional: Fallback to the default voice if the specified one isn't available
							const utter = new SpeechSynthesisUtterance(TtsMessage());
							utter.rate = TtsRate();
							utter.pitch = TtsPitch();
							window.speechSynthesis.cancel();
							window.speechSynthesis.speak(utter);
						}
					});

					// Ensure voices are loaded before the button is clicked.
					// This event is crucial for the getVoices() method to return a non-empty array.
					window.speechSynthesis.onvoiceschanged = () => {
						// This event handler ensures the voice list is updated.
						// The code inside the click listener can now reliably find a voice.
						console.log("Speech synthesis voices have changed (and are likely loaded).");
					};		</script>
			</div>
		</details>

		<script type="module">
			// 1. Define function at the module level (not inside the 'load' listener)
			async function addMessageToTable() {
				const form = document.getElementById('messageForm');
				const tableBody = document.querySelector('#messagesTable tbody');

				if (!form || !tableBody) {
					console.error("Form or Table Body not found.");
					return;
				}

				const user = form.user.value;
				const message = form.message.value;
				const ttsFlags = form.tts_flags.value;

				if (!user || !message || !ttsFlags) {
					alert("Please fill in all required fields.");
					return;
				}

				const newIndex = tableBody.rows.length + 1;
				const date = new Date().toLocaleTimeString('en-US', {hour12: false});

				// 1. Create the new row
				const newRow = tableBody.insertRow();

				// 2. Insert cells with data and elements (10 columns total)
				newRow.insertCell().textContent = newIndex;
				newRow.insertCell().textContent = user;
				newRow.insertCell().textContent = date;
				newRow.insertCell().textContent = ttsFlags;
				newRow.insertCell().textContent = await window.monitorMessages.EvaluateMessageScore(message);
				newRow.insertCell().textContent = message;
				newRow.insertCell().innerHTML = '<button>Play</button>';
				newRow.insertCell().innerHTML = '<input type="checkbox" checked>';
				newRow.insertCell().innerHTML = '<button>Timeout</button>';
				newRow.insertCell().innerHTML = '<button>Block</button>';
				newRow.insertCell().innerHTML = '<button>Ban</button>';

				form.message.value = '';
				form.message.focus();
			}

			// NOTE: If you also have the 'exportTableToJson' function, define it here as well.

			// 2. Use DOMContentLoaded for listener attachment (Better than 'load')
			document.addEventListener('DOMContentLoaded', () => {
				const addButton = document.getElementById('addButton');

				if (addButton) {
					// 3. FIX: Pass the function reference (NO parentheses)
					addButton.addEventListener('click', addMessageToTable);
				} else {
					console.error("Button with ID 'addButton' not found. Check HTML.");
				}
			});

		</script>
		<details>
			<summary>messages</summary>
			<div>
				<h3>Add Test Message</h3>
				<form id="messageForm">
					<label for="user">User:</label>
					<input type="text" id="user" name="user" value="TestUser" required>

					<label for="message">Message:</label>
					<input type="text" id="message" name="message" value="Hello, world!" required>

					<label for="tts_flags">TTS Flags (JSON):</label>
					<input type="text" id="tts_flags" name="tts_flags" value='{"p":1.5,"r":0.8", "v": 50}' required>

					<button type="button" id="addButton">Add Message to Table</button>
				</form>

			</div>
			<div>
				<script>
					function exportTableToJson() {
						// 1. Get the table element
						const table = document.getElementById("messagesTable");
						if (!table) {
							console.error("Table with id 'messagesTable' not found.");
							return;
						}

						// 2. Extract header names (column names)
						// Assumes the first row is the header (<thead>)
						const headers = [];
						const headerRow = table.querySelector('thead tr') || table.rows[0];
						if (headerRow) {
							for (let i = 0; i < headerRow.cells.length; i++) {
								const cellText = headerRow.cells[i].textContent.trim();

								// Skip columns that are buttons or checkboxes (based on your column list)
								// You can adjust these indices if your table structure changes
								// The columns to skip are: play message, in tts que, time user out, block user from tts, ban user
								// These correspond to columns 5, 6, 7, 8, 9 (0-indexed)
								if (i < 5 || i === 6) {
									// Only include the text-based columns and the checkbox column 'in tts que'
									// For 'in tts que', we use the header name for consistency
									headers.push(cellText);
								}
							}
						} else {
							console.warn("Could not find a header row (<thead> or first <tr>). Using default keys.");
							// Fallback for missing header
							headers.push("index", "user", "date", "tts flags", "message");
						}


						// 3. Extract the row data
						const data = [];
						// Start from 1 to skip the header row, if no <thead> is used, otherwise iterate all <tr> in <tbody>
						const bodyRows = table.querySelector('tbody') ? table.querySelector('tbody').rows : Array.from(table.rows).slice(1);

						for (const row of bodyRows) {
							const rowData = {};
							let headerIndex = 0;

							for (let i = 0; i < row.cells.length; i++) {
								const cell = row.cells[i];

								// Skip the action/button columns (5, 7, 8, 9)
								if (i === 5 || i >= 7) {
									continue;
								}

								// Handle the Checkbox column: 'in tts que' (index 6)
								if (i === 6) {
									const checkbox = cell.querySelector('input[type="checkbox"]');
									const key = headers[headerIndex] || "in tts que";
									rowData[key] = checkbox ? checkbox.checked : false;
								}
								// Handle the JSON Object column: 'tts flags' (index 3)
								else if (i === 3) {
									const text = cell.textContent.trim();
									const key = headers[headerIndex] || "tts flags";
									try {
										// Attempt to parse the cell content as a JSON object
										rowData[key] = JSON.parse(text);
									} catch (e) {
										// If parsing fails, store as a string or a default empty object
										console.warn(`Could not parse JSON in 'tts flags' for row ${row.rowIndex}: ${text}`);
										rowData[key] = text;
									}
								}
								// Handle all other text/int columns (0, 1, 2, 4)
								else {
									const key = headers[headerIndex] || `col${i}`;
									rowData[key] = cell.textContent.trim();

									// Simple type conversion for 'index' column
									if (key === 'index' && !isNaN(parseInt(rowData[key]))) {
										rowData[key] = parseInt(rowData[key]);
									}
								}

								headerIndex++;
							}
							data.push(rowData);
						}

						// 4. Convert the data array to a JSON string
						const jsonString = JSON.stringify(data, null, 2); // 'null, 2' for pretty-printing

						// 5. Create a Blob and initiate download
						const blob = new Blob([jsonString], {type: "application/json"});
						const url = URL.createObjectURL(blob);

						const a = document.createElement("a");
						a.href = url;
						a.download = "messages_data.json"; // Suggested file name
						document.body.appendChild(a);
						a.click();
						document.body.removeChild(a);

						// Clean up the URL object
						URL.revokeObjectURL(url);
					}
				</script>
				<button onclick="exportTableToJson()">
					Export Table Data to JSON
				</button>
			</div>
		</details>


		<br>
		<br>

		<details>
			<summary>clip timestamps</summary>
			<table style="width:100%;">
				<tbody>
					<tr>
						<th>author</th>
						<th>message</th>
						<th>timestamp</th>
					</tr>
				</tbody>
			</table>
		</details>

		<details>
			<!--
		userData = {
			user1 = {
				points: int,
				warnings: [old -> new],
				isBanned: [old -> new],
				notes: char* []
			},
		}	
		-->
			<summary>users</summary>
			<table style="width:100%; max-height:60vh; overflow:scroll;">
				<tbody>
					<tr>
						<th>users</th>
						<th>points</th>
						<th>warnings</th>
						<th>banHistory</th>
						<th>notes</th>
					</tr>
				</tbody>
			</table>
		</details>
		<form>
			<style>
				#addProcessedMessageField>div {
					display: flex;
					flex-direction: row;
					justify-content: space-between;
					max-width: 30em;
				}
			</style>
			<details>
				<summary>add a processed message</summary>
				<fieldset id="addProcessedMessageField">
					<legend>add test message</legend>
					<div>
						<script>
							window.addEventListener('load', (async () => {
								// Helper function to create elements with properties (MUST BE DEFINED HERE)
								function CE(args = {elem: 'div', id: undefined, class: undefined, innerText: undefined, innerHTML: undefined, onclick: undefined, src: undefined, value: undefined}) {
									let elem = document.createElement(args.elem || 'div'); // Use 'div' as default
									if (args.id) elem.id = args.id;
									if (args.class) elem.className = args.class;
									if (args.innerText) elem.innerText = args.innerText;
									if (args.innerHTML) elem.innerHTML = args.innerHTML;
									if (args.onclick) elem.onclick = args.onclick;
									if (args.onkeyup) elem.onkeyup = args.onkeyup;
									if (args.src) elem.src = args.src;
									if (args.value) elem.value = args.value;
									return elem;
								};

								// 1. Define a function to wait for the object
								const waitForMonitorMessages = () => {
									return new Promise(resolve => {
										const check = () => {
											if (window.monitorMessages && window.monitorMessages.GetAndReturnEmptyMessageTemplate) {
												resolve(window.monitorMessages);
											} else {
												// Check every 50 milliseconds
												setTimeout(check, 50);
											}
										};
										check();
									});
								};

								try {
									let mm = await waitForMonitorMessages();
									let mT = await mm.GetAndReturnEmptyMessageTemplate();

									console.warn("Message Template:", JSON.stringify(mT));

									if (mT === undefined || mT === null) {
										throw new Error("GetAndReturnEmptyMessageTemplate returned undefined or null.");
									}

									let pmf = document.getElementById("addProcessedMessageField");
									if (!pmf) {
										console.error("Target container 'addProcessedMessageField' not found in the DOM.");
										return;
									}

									let container, label, input, key, value;
									const keys = Object.keys(mT);

									// Loop through keys and create inputs
									for (let i = 0; i < keys.length; ++i) {
										console.log("adding input");
										key = keys[i];
										value = mT[key]; // Assuming value is the default value or empty string

										container = CE({class: `processedMessageField-inputContainer`});

										// LABEL
										label = CE({elem: 'label', id: `processedMessageField-${key}`, innerText: key + ": "});
										container.appendChild(label);

										// INPUT (Assuming you want an input field)
										let defaultValue;
										switch (key) {
											case ("template_version"):
												defaultValue = "1";
												break;
											case ("authorName"):
												defaultValue = "webGUI-tester";
												break;
											case ("authorId"):
												defaultValue = "0000-0000-0000-0000";
												break;
											case ("streamOrigin"):
												defaultValue = "notLive";
												break;
											case ("date"):
												defaultValue = Date.now();
												break;
											case ("commands:"):
												defaultValue = "FIX ME BEFORE YOU USE ME";
												break;
											case ("processedMessage"):
												defaultValue = "";
												break;
											case ("platform:"):
												defaultValue = "webGUI";
												break;
											case ("rawMessage"):
												defaultValue = "Hello from the webGUI!";
												break;
											case ("score"):
												defaultValue = undefined;
												break;
											case ("isDeleted"):
												defaultValue = "false";
												break;
											default:
												defaultValue = "";
												break;
										}
										input = CE({elem: 'input', id: `processedMessageField-inputContainerFor${key}`, value: defaultValue, });

										container.appendChild(input);

										if (key == "processedMessage") {
											console.log("doing special stuff for the processed message");
											async function UpdateTestScoreStuff() {
												let shortestMaxMessage = 255;
												let input = document.getElementById("processedMessageField-inputContainerForprocessedMessage");
												let rcd = document.getElementById("processedMessageField-remainingCharsDisplay");
												let ms = document.getElementById("processedMessageField-score");
												let score = await window.monitorMessages.ScoreMessage(input.value);
												let scoreColor = await window.monitorMessages.ColorFromScoreValue(score);
												input.style.borderColor = scoreColor;
												rcd.innerText = String(input.value.length + "/" + shortestMaxMessage);
												if (shortestMaxMessage / input.value.length > 1) {rcd.style.color = "light-green !important";} // BUG: 
												else {rcd.style.color = "light-red";} // BUG: 
												ms.innerText = score;
												ms.style.borderColor = scoreColor; // BUG: 
											}
											input.onkeyup = UpdateTestScoreStuff;
											let rcd = CE({elem: "output", id: "processedMessageField-remainingCharsDisplay", });
											container.appendChild(rcd);
											let scoreDis = CE({elem: "output", id: "processedMessageField-score", });
											container.appendChild(scoreDis);
										}

										pmf.appendChild(container);
									}
									console.log("added all vars to page");
								} catch (error) {
									console.error("Initialization failed:", error);
								}
							}));

						</script>
						<!--
					<div>
						<input id="testMessage" type='text' style="width:90%;" onkeydown='UpdateTestScoreStuff();'
							onchange='UpdateTestScoreStuff()'>
					</div>
					<div style="display:flexbox; flex-direction:row;">
						<div style="display:inline-block;">
							<lable>char count:</lable>
							<output id="testMessage-remainingCharsDisplay">0/255</output>
						</div>
						<div style="display:inline-block;">
							<label>score:</label>
							<output id="testMessage-score">...</output>
						</div>
					</div>
					<div>
						<label>platform</label>
						<input type='text' value='system'>
					</div>
					<div>
						<label></label>
					</div>
-->
					</div>
				</fieldset>
			</details>
		</form>
		<table id="messagesTable">
			<tbody>
				<tr>
					<!-- do not impliment this, 3 types of data rows are possible, whitelist: do nothing, graylist: make the row yellow, blacklist: check the "block user from tts" box -->
					<th>index</th> <!-- index of message -->
					<th>user</th> <!-- @ of user on youtube -->
					<th style="max-width:3em; overflow:hidden;">date</th> <!-- datetime of message -->
					<th style="max-width:3em;">tts flags</th>
					<!-- the 3 values that exist are: -r for rate, -v for voice, and -p for pitch -->
					<th>msg score</th>
					<th>message</th> <!-- the message -->
					<th>play message</th> <!-- the message -->
					<th>in tts que</th>
					<!-- is a checkbox, if message starts with: "!TTS", "!TIB", or "!BOT" automatically add -->
					<th>time user out</th> <!-- if clicked, will time user out for 10 minute-->
					<th>block user from tts</th>
					<th>ban user </th>
					<!-- when clicked, will ban the user from the channel, only after entering a special 6 digit pin (prompt the user for pin on click then do), -->
					<!-- is a checkbox, if checked messages from this user will not automatically be added to the tts queue -->
				</tr>
			</tbody>
		</table>
		<div>
			<script>
				/**
				 * Exports a JavaScript object as a downloaded JSON file.
				 * * @param {object} data - The JavaScript object to export.
				 * @param {string} [filename='data.json'] - The desired name for the downloaded file.
				 */
				function downloadJson(data, filename = 'data.json') {
					if (typeof data !== 'object' || data === null) {
						console.error("Invalid data provided. Must be a non-null object.");
						return;
					}

					try {
						// 1. Convert the object to a JSON string
						const jsonString = JSON.stringify(data, null, 2); // 'null, 2' formats the JSON nicely

						// 2. Create a Blob containing the JSON data
						const blob = new Blob([jsonString], {type: 'application/json'});

						// 3. Create a temporary URL for the Blob
						const url = URL.createObjectURL(blob);

						// 4. Create a temporary <a> element
						const a = document.createElement('a');
						a.href = url;
						a.download = filename; // Set the filename

						// 5. Simulate a click to trigger the download
						document.body.appendChild(a);
						a.click();

						// 6. Clean up the temporary URL and element
						document.body.removeChild(a);
						URL.revokeObjectURL(url);

						console.log(`Successfully downloaded file: ${filename}`);

					} catch (error) {
						console.error("Failed to generate or download JSON file:", error);
					}
				}
			</script>
			<form>
				<div>
					<label>download unprocesed messages</label>
					<input type="button" value="download json" onclick="
							console.log('getting all data');
							downloadJson(window.monitorMessages.GetAndReturnUnprocessedMessages(), `unprocessedMessages-${Date.now()}.json`)
						">
				</div>
				<div>
					<label>download processed messages</label>
					<input type="button" value="download json" onclick="
							console.log('getting all data');
							downloadJson(window.monitorMessages.GetAndReturnProcessedMessages(), `processedMessages-${Date.now()}.json`)
						">
				</div>
				<div>
					<label>download user data</label>
					<input type="button" value="download json" onclick="
							console.log('getting all data');
							downloadJson(window.monitorMessages.GetAndReturnUsers(), `userData-${Date.now()}.json`)
						">
				</div>
				<div>
					<label>download all data</label>
					<input type="button" value="download json" onclick="
							console.log('getting all data');
							downloadJson(window.monitorMessages.GetAndReturnUsers(), `unprocessedMessages-${Date.now()}.json`);
							downloadJson(window.monitorMessages.GetAndReturnProcessedMessages(), `processedMessages-${Date.now()}.json`);
							downloadJson(window.monitorMessages.GetAndReturnUnprocessedMessages(), `userData-${Date.now()}.json`);
						">
				</div>
			</form>
		</div>
</body>
